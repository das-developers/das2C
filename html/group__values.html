<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>das2C: Values</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="das2logo-32.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">das2C
   </div>
   <div id="projectbrief">das2 core C utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Values</div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic data storage elements.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Basic data storage elements. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdatum__t.html">datum_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value and it's units.  <a href="structdatum__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad87a6a69f4bf3d3f8027e594226cd9fc"><td class="memItemLeft" align="right" valign="top"><a id="gad87a6a69f4bf3d3f8027e594226cd9fc"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gad87a6a69f4bf3d3f8027e594226cd9fc">das_valcmp_func</a>) (const byte *, const byte *)</td></tr>
<tr class="memdesc:gad87a6a69f4bf3d3f8027e594226cd9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functions look like this. <br /></td></tr>
<tr class="separator:gad87a6a69f4bf3d3f8027e594226cd9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga76f88eaf0d1237a13e481f0f03e7153a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga76f88eaf0d1237a13e481f0f03e7153a">das_val_type_e</a> { <br />
&#160;&#160;<a class="el" href="group__values.html#gga76f88eaf0d1237a13e481f0f03e7153aacd357630ae0ef37f194c322b8e7aaa89">vtUnknown</a> = 0
, <a class="el" href="group__values.html#gga76f88eaf0d1237a13e481f0f03e7153aa0b48e9f85996bca01cbc4ef867a14d87">vtByte</a>, 
<a class="el" href="group__values.html#gga76f88eaf0d1237a13e481f0f03e7153aac447f3d9dd9e4b250990ede36457e9c6">vtUShort</a>, 
<a class="el" href="group__values.html#gga76f88eaf0d1237a13e481f0f03e7153aa0fe203efac33a548bb0793cbd6a4be9f">vtShort</a>, 
<br />
&#160;&#160;<a class="el" href="group__values.html#gga76f88eaf0d1237a13e481f0f03e7153aa3c0bd6e9190ffefd8bfd656b32d1cb09">vtInt</a>, 
<a class="el" href="group__values.html#gga76f88eaf0d1237a13e481f0f03e7153aaa6df9ef15e5ff7578d1691627921c141">vtLong</a>, 
<a class="el" href="group__values.html#gga76f88eaf0d1237a13e481f0f03e7153aa2dde9d0564f21ee871eadd6a45fc59db">vtFloat</a>, 
<a class="el" href="group__values.html#gga76f88eaf0d1237a13e481f0f03e7153aafd6ca1d04415b7534d47a76ddd27aca8">vtDouble</a>, 
<br />
&#160;&#160;<a class="el" href="group__values.html#gga76f88eaf0d1237a13e481f0f03e7153aadab1a2519cac5ff5d04d295ebc90f618">vtTime</a>, 
<a class="el" href="group__values.html#gga76f88eaf0d1237a13e481f0f03e7153aaaa403f3a4de6b73d20d8ed606d1aa9ff">vtText</a>, 
<a class="el" href="group__values.html#gga76f88eaf0d1237a13e481f0f03e7153aaea5926c173c777754c86cd0a6b5c8445">vtByteSeq</a>
<br />
 }</td></tr>
<tr class="memdesc:ga76f88eaf0d1237a13e481f0f03e7153a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of types stored in Das Array (DasAry) objects Not that any kind of value may be stored in a Das Array, but most of these types have runtime type safty checks.  <a href="group__values.html#ga76f88eaf0d1237a13e481f0f03e7153a">More...</a><br /></td></tr>
<tr class="separator:ga76f88eaf0d1237a13e481f0f03e7153a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0ca591fbe8807d0049157fafcd32878b"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga0ca591fbe8807d0049157fafcd32878b">das_datum_fromStr</a> (das_datum *pThis, const char *sStr)</td></tr>
<tr class="memdesc:ga0ca591fbe8807d0049157fafcd32878b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a numeric datum from a value and units string.  <a href="group__values.html#ga0ca591fbe8807d0049157fafcd32878b">More...</a><br /></td></tr>
<tr class="separator:ga0ca591fbe8807d0049157fafcd32878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf03a00a91a69071477e53cad14674f1f"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gaf03a00a91a69071477e53cad14674f1f">das_datum_fromDbl</a> (das_datum *pThis, double value, <a class="el" href="group__units.html#ga69f5744c4a283544d36b64714e8b422d">das_units</a> units)</td></tr>
<tr class="memdesc:gaf03a00a91a69071477e53cad14674f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a datum from a double value and units.  <a href="group__values.html#gaf03a00a91a69071477e53cad14674f1f">More...</a><br /></td></tr>
<tr class="separator:gaf03a00a91a69071477e53cad14674f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fb40cc9525ae0bdd374ccbf1d563f1"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gad4fb40cc9525ae0bdd374ccbf1d563f1">das_datum_wrapStr</a> (das_datum *pTHis, const char *sStr, <a class="el" href="group__units.html#ga69f5744c4a283544d36b64714e8b422d">das_units</a> units)</td></tr>
<tr class="memdesc:gad4fb40cc9525ae0bdd374ccbf1d563f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an external string as a datum.  <a href="group__values.html#gad4fb40cc9525ae0bdd374ccbf1d563f1">More...</a><br /></td></tr>
<tr class="separator:gad4fb40cc9525ae0bdd374ccbf1d563f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a09c66eb757ab4ec1ca5e078c67a881"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga0a09c66eb757ab4ec1ca5e078c67a881">das_datum_byteSeq</a> (das_datum *pThis, das_byteseq seq, <a class="el" href="group__units.html#ga69f5744c4a283544d36b64714e8b422d">das_units</a> units)</td></tr>
<tr class="memdesc:ga0a09c66eb757ab4ec1ca5e078c67a881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an external unknown type pointer as a datum.  <a href="group__values.html#ga0a09c66eb757ab4ec1ca5e078c67a881">More...</a><br /></td></tr>
<tr class="separator:ga0a09c66eb757ab4ec1ca5e078c67a881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f3ac224a3cf321760b78593b86dff0"><td class="memItemLeft" align="right" valign="top">DAS_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga62f3ac224a3cf321760b78593b86dff0">das_datum_toStr</a> (const das_datum *pThis, char *sStr, size_t uLen, int nFracDigits)</td></tr>
<tr class="memdesc:ga62f3ac224a3cf321760b78593b86dff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a UTF-8 string representation of a datum to a buffer.  <a href="group__values.html#ga62f3ac224a3cf321760b78593b86dff0">More...</a><br /></td></tr>
<tr class="separator:ga62f3ac224a3cf321760b78593b86dff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f9c9bd78ac22794d6f870d7cd560ff9"><td class="memItemLeft" align="right" valign="top">DAS_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga1f9c9bd78ac22794d6f870d7cd560ff9">das_datum_toStrValOnly</a> (const das_datum *pThis, char *sStr, size_t uLen, int nFracDigits)</td></tr>
<tr class="memdesc:ga1f9c9bd78ac22794d6f870d7cd560ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as das_datum_toStr, but never print the units.  <a href="group__values.html#ga1f9c9bd78ac22794d6f870d7cd560ff9">More...</a><br /></td></tr>
<tr class="separator:ga1f9c9bd78ac22794d6f870d7cd560ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad561a3c1f2582f0ba0eb64fc3602527"><td class="memItemLeft" align="right" valign="top">DAS_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gaad561a3c1f2582f0ba0eb64fc3602527">das_datum_toDbl</a> (const das_datum *pThis)</td></tr>
<tr class="memdesc:gaad561a3c1f2582f0ba0eb64fc3602527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a datum value as a double.  <a href="group__values.html#gaad561a3c1f2582f0ba0eb64fc3602527">More...</a><br /></td></tr>
<tr class="separator:gaad561a3c1f2582f0ba0eb64fc3602527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa1ed27e9726ec502b1cfc4c3d77fe45"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gafa1ed27e9726ec502b1cfc4c3d77fe45">das_datum_toEpoch</a> (const das_datum *pThis, <a class="el" href="group__units.html#ga69f5744c4a283544d36b64714e8b422d">das_units</a> epoch, double *pResult)</td></tr>
<tr class="memdesc:gafa1ed27e9726ec502b1cfc4c3d77fe45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a time datum value as a double at a given epoch an scale.  <a href="group__values.html#gafa1ed27e9726ec502b1cfc4c3d77fe45">More...</a><br /></td></tr>
<tr class="separator:gafa1ed27e9726ec502b1cfc4c3d77fe45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfce99e4553db5d18eb4bd450ee6c7aa"><td class="memItemLeft" align="right" valign="top">const DAS_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gabfce99e4553db5d18eb4bd450ee6c7aa">das_vt_fill</a> (das_val_type vt)</td></tr>
<tr class="memdesc:gabfce99e4553db5d18eb4bd450ee6c7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default fill value for a given element type.  <a href="group__values.html#gabfce99e4553db5d18eb4bd450ee6c7aa">More...</a><br /></td></tr>
<tr class="separator:gabfce99e4553db5d18eb4bd450ee6c7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f2c75a7a5a3726055a54ec8e54b45a3"><td class="memItemLeft" align="right" valign="top"><a id="ga5f2c75a7a5a3726055a54ec8e54b45a3"></a>
DAS_API size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga5f2c75a7a5a3726055a54ec8e54b45a3">das_vt_size</a> (das_val_type vt)</td></tr>
<tr class="memdesc:ga5f2c75a7a5a3726055a54ec8e54b45a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size in bytes for a given element type. <br /></td></tr>
<tr class="separator:ga5f2c75a7a5a3726055a54ec8e54b45a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b8011e577bdbdf2fcc8b2a1648abeea"><td class="memItemLeft" align="right" valign="top"><a id="ga6b8011e577bdbdf2fcc8b2a1648abeea"></a>
const DAS_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga6b8011e577bdbdf2fcc8b2a1648abeea">das_vt_toStr</a> (das_val_type vt)</td></tr>
<tr class="memdesc:ga6b8011e577bdbdf2fcc8b2a1648abeea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a text string representation of an element type. <br /></td></tr>
<tr class="separator:ga6b8011e577bdbdf2fcc8b2a1648abeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97463f4ad7a43997c1505f12e9e3bfd5"><td class="memItemLeft" align="right" valign="top"><a id="ga97463f4ad7a43997c1505f12e9e3bfd5"></a>
DAS_API <a class="el" href="group__values.html#gad87a6a69f4bf3d3f8027e594226cd9fc">das_valcmp_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga97463f4ad7a43997c1505f12e9e3bfd5">das_vt_getcmp</a> (das_val_type vt)</td></tr>
<tr class="memdesc:ga97463f4ad7a43997c1505f12e9e3bfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the comparison function for two values of this type. <br /></td></tr>
<tr class="separator:ga97463f4ad7a43997c1505f12e9e3bfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e987e793fd2aac803b7dda0ab5ed24"><td class="memItemLeft" align="right" valign="top">DAS_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga97e987e793fd2aac803b7dda0ab5ed24">das_vt_cmpAny</a> (const byte *pA, das_val_type vtA, const byte *pB, das_val_type vtB)</td></tr>
<tr class="memdesc:ga97e987e793fd2aac803b7dda0ab5ed24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare any two value types for equality.  <a href="group__values.html#ga97e987e793fd2aac803b7dda0ab5ed24">More...</a><br /></td></tr>
<tr class="separator:ga97e987e793fd2aac803b7dda0ab5ed24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd1179294ef2a637e4a585a8e9be8fff"><td class="memItemLeft" align="right" valign="top">DAS_API das_val_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gabd1179294ef2a637e4a585a8e9be8fff">das_vt_merge</a> (das_val_type right, int op, das_val_type left)</td></tr>
<tr class="memdesc:gabd1179294ef2a637e4a585a8e9be8fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">What would be the resulting type given an operation on the given value type.  <a href="group__values.html#gabd1179294ef2a637e4a585a8e9be8fff">More...</a><br /></td></tr>
<tr class="separator:gabd1179294ef2a637e4a585a8e9be8fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53db8406b14aa454d2fc56048a27e0d7"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga53db8406b14aa454d2fc56048a27e0d7">das_str2double</a> (const char *str, double *pRes)</td></tr>
<tr class="memdesc:ga53db8406b14aa454d2fc56048a27e0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string value to a 8-byte float, similar to strtod(3).  <a href="group__values.html#ga53db8406b14aa454d2fc56048a27e0d7">More...</a><br /></td></tr>
<tr class="separator:ga53db8406b14aa454d2fc56048a27e0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56d10a5c35e5f09a46d9b9350b92ff56"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga56d10a5c35e5f09a46d9b9350b92ff56">das_str2int</a> (const char *str, int *pRes)</td></tr>
<tr class="memdesc:ga56d10a5c35e5f09a46d9b9350b92ff56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the initial portion of a string to an integer with explicit over/underflow checks.  <a href="group__values.html#ga56d10a5c35e5f09a46d9b9350b92ff56">More...</a><br /></td></tr>
<tr class="separator:ga56d10a5c35e5f09a46d9b9350b92ff56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga224b6da8194ebb8bfe0f120ac6bf5ddd"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga224b6da8194ebb8bfe0f120ac6bf5ddd">das_str2bool</a> (const char *str, bool *pRes)</td></tr>
<tr class="memdesc:ga224b6da8194ebb8bfe0f120ac6bf5ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string value to a boolean value.  <a href="group__values.html#ga224b6da8194ebb8bfe0f120ac6bf5ddd">More...</a><br /></td></tr>
<tr class="separator:ga224b6da8194ebb8bfe0f120ac6bf5ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55e7d6d83698b52a370aa7c55dc21958"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga55e7d6d83698b52a370aa7c55dc21958">das_str2baseint</a> (const char *str, int base, int *pRes)</td></tr>
<tr class="memdesc:ga55e7d6d83698b52a370aa7c55dc21958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to an integer with explicit base and overflow checking.  <a href="group__values.html#ga55e7d6d83698b52a370aa7c55dc21958">More...</a><br /></td></tr>
<tr class="separator:ga55e7d6d83698b52a370aa7c55dc21958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf95f28a7f862a7acb352cd2eeb13d61"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gadf95f28a7f862a7acb352cd2eeb13d61">das_strn2baseint</a> (const char *str, int nLen, int base, int *pRes)</td></tr>
<tr class="memdesc:gadf95f28a7f862a7acb352cd2eeb13d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an explicit length string to an integer with explicit base with over/underflow checks.  <a href="group__values.html#gadf95f28a7f862a7acb352cd2eeb13d61">More...</a><br /></td></tr>
<tr class="separator:gadf95f28a7f862a7acb352cd2eeb13d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48572b70b1f5dad97885532465270907"><td class="memItemLeft" align="right" valign="top">DAS_API double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga48572b70b1f5dad97885532465270907">das_csv2doubles</a> (const char *s, int *nitems)</td></tr>
<tr class="memdesc:ga48572b70b1f5dad97885532465270907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a comma separated list of ASCII values into a double array.  <a href="group__values.html#ga48572b70b1f5dad97885532465270907">More...</a><br /></td></tr>
<tr class="separator:ga48572b70b1f5dad97885532465270907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaded93ede3f543cbe20c6d143f47ff4b7"><td class="memItemLeft" align="right" valign="top">DAS_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gaded93ede3f543cbe20c6d143f47ff4b7">das_doubles2csv</a> (char *buf, const double *value, int nitems)</td></tr>
<tr class="memdesc:gaded93ede3f543cbe20c6d143f47ff4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an array of doubles into a string buffer.  <a href="group__values.html#gaded93ede3f543cbe20c6d143f47ff4b7">More...</a><br /></td></tr>
<tr class="separator:gaded93ede3f543cbe20c6d143f47ff4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga76f88eaf0d1237a13e481f0f03e7153a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76f88eaf0d1237a13e481f0f03e7153a">&#9670;&nbsp;</a></span>das_val_type_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__values.html#ga76f88eaf0d1237a13e481f0f03e7153a">das_val_type_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of types stored in Das Array (DasAry) objects Not that any kind of value may be stored in a Das Array, but most of these types have runtime type safty checks. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga76f88eaf0d1237a13e481f0f03e7153aacd357630ae0ef37f194c322b8e7aaa89"></a>vtUnknown&#160;</td><td class="fielddoc"><p>For generic storage, designates elements as unknown, you have to cast the array return values yourself. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76f88eaf0d1237a13e481f0f03e7153aa0b48e9f85996bca01cbc4ef867a14d87"></a>vtByte&#160;</td><td class="fielddoc"><p>Indicates array values are unsigned 8-bit unsigned integers (bytes) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76f88eaf0d1237a13e481f0f03e7153aac447f3d9dd9e4b250990ede36457e9c6"></a>vtUShort&#160;</td><td class="fielddoc"><p>Indicates array values are unsigned 16-bit integers (shorts) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76f88eaf0d1237a13e481f0f03e7153aa0fe203efac33a548bb0793cbd6a4be9f"></a>vtShort&#160;</td><td class="fielddoc"><p>Indicates array values are signed 16-bit integers (shorts) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76f88eaf0d1237a13e481f0f03e7153aa3c0bd6e9190ffefd8bfd656b32d1cb09"></a>vtInt&#160;</td><td class="fielddoc"><p>Indicates array values are signed 32-bit integers (ints) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76f88eaf0d1237a13e481f0f03e7153aaa6df9ef15e5ff7578d1691627921c141"></a>vtLong&#160;</td><td class="fielddoc"><p>Indicates array values are signed 64-bit integers (longs) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76f88eaf0d1237a13e481f0f03e7153aa2dde9d0564f21ee871eadd6a45fc59db"></a>vtFloat&#160;</td><td class="fielddoc"><p>Indicates array values are 32-bit floating point values (floats) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76f88eaf0d1237a13e481f0f03e7153aafd6ca1d04415b7534d47a76ddd27aca8"></a>vtDouble&#160;</td><td class="fielddoc"><p>Indicates array values are 64-bit floating point values (doubles) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76f88eaf0d1237a13e481f0f03e7153aadab1a2519cac5ff5d04d295ebc90f618"></a>vtTime&#160;</td><td class="fielddoc"><p>Indicates array values are <a class="el" href="structdas__time__t.html" title="Basic date-time structure used throughout the Das1 &amp; Das2 utilities.">das_time_t</a> structures. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76f88eaf0d1237a13e481f0f03e7153aaaa403f3a4de6b73d20d8ed606d1aa9ff"></a>vtText&#160;</td><td class="fielddoc"><p>Indicates datum values are const char* pointers to null terminated UTF-8 strings. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76f88eaf0d1237a13e481f0f03e7153aaea5926c173c777754c86cd0a6b5c8445"></a>vtByteSeq&#160;</td><td class="fielddoc"><p>Indicates values are size_t plus const byte* pairs, no more is known about the bytes. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0ca591fbe8807d0049157fafcd32878b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ca591fbe8807d0049157fafcd32878b">&#9670;&nbsp;</a></span>das_datum_fromStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_datum_fromStr </td>
          <td>(</td>
          <td class="paramtype">das_datum *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a numeric datum from a value and units string. </p>
<p><br  />
</p>
<p>Note that this function will not initialize text datums. This is because text datums only carry a const char* pointer, but not the string itself. Call Datum_wrapStr() to make text datums.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>pointer to the datum structure to initialize </td></tr>
    <tr><td class="paramname">sStr</td><td>the value plus it's units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the string was parseable as a datum, false otherwise. </dd></dl>

</div>
</div>
<a id="gaf03a00a91a69071477e53cad14674f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf03a00a91a69071477e53cad14674f1f">&#9670;&nbsp;</a></span>das_datum_fromDbl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_datum_fromDbl </td>
          <td>(</td>
          <td class="paramtype">das_datum *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga69f5744c4a283544d36b64714e8b422d">das_units</a>&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a datum from a double value and units. </p>
<p>This is the most commonly used type of datum, followed by time datums</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">units</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns true. </dd></dl>

</div>
</div>
<a id="gad4fb40cc9525ae0bdd374ccbf1d563f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4fb40cc9525ae0bdd374ccbf1d563f1">&#9670;&nbsp;</a></span>das_datum_wrapStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_datum_wrapStr </td>
          <td>(</td>
          <td class="paramtype">das_datum *&#160;</td>
          <td class="paramname"><em>pTHis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga69f5744c4a283544d36b64714e8b422d">das_units</a>&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap an external string as a datum. </p>
<p>This is useful for events lists as well as non-numeric coordinate points. For example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>** cites[] = {</div>
<div class="line">   <span class="stringliteral">&quot;Iowa City&quot;</span>, <span class="stringliteral">&quot;Coralville&quot;</span>, <span class="stringliteral">&quot;North Liberty&quot;</span>, <span class="stringliteral">&quot;Cedar Rapids&quot;</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Make a datum array representing a few cities in Eastern Iowa with units</div>
<div class="line">of <span class="stringliteral">&quot;city&quot;</span>.</div>
<div class="line"> </div>
<div class="line">datum locations[4];</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i)</div>
<div class="line">    das_datum_initStr(locations + i, <span class="stringliteral">&quot;city&quot;</span>, cities[i]);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga0a09c66eb757ab4ec1ca5e078c67a881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a09c66eb757ab4ec1ca5e078c67a881">&#9670;&nbsp;</a></span>das_datum_byteSeq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_datum_byteSeq </td>
          <td>(</td>
          <td class="paramtype">das_datum *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">das_byteseq&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga69f5744c4a283544d36b64714e8b422d">das_units</a>&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap an external unknown type pointer as a datum. </p>
<p>This is for special user defined data types unknown to libdas2. The type of the datum will be vtByteSeq (a byte sequence) </p>

</div>
</div>
<a id="ga62f3ac224a3cf321760b78593b86dff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62f3ac224a3cf321760b78593b86dff0">&#9670;&nbsp;</a></span>das_datum_toStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API char* das_datum_toStr </td>
          <td>(</td>
          <td class="paramtype">const das_datum *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFracDigits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a UTF-8 string representation of a datum to a buffer. </p>
<p>Time values are printed as ISO-8601 time strings, all floating point values are printed using a generic exponential notation. String datums are simply printed, and byteseq datums are printed as hex-digits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The datum to write</td></tr>
    <tr><td class="paramname">sStr</td><td>The buffer to write the reprenestation to</td></tr>
    <tr><td class="paramname">uLen</td><td>The amount of space available for writing</td></tr>
    <tr><td class="paramname">nFracDigits</td><td>Number of digits after the decimal place to print. for multi-part values, such a calendar times this refers to the number of digits after the decimal point for the last component only. Use -1 to get default fractional digits which are 5 for a float, 9 for a double and millisec precision for times.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The write point for adding more text to the buffer. To see how much text was written subtract the initial buffer (sBuf) from this return value. </dd></dl>

</div>
</div>
<a id="ga1f9c9bd78ac22794d6f870d7cd560ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f9c9bd78ac22794d6f870d7cd560ff9">&#9670;&nbsp;</a></span>das_datum_toStrValOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API char* das_datum_toStrValOnly </td>
          <td>(</td>
          <td class="paramtype">const das_datum *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFracDigits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as das_datum_toStr, but never print the units. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__values.html#ga62f3ac224a3cf321760b78593b86dff0" title="Write a UTF-8 string representation of a datum to a buffer.">das_datum_toStr</a> </dd></dl>

</div>
</div>
<a id="gaad561a3c1f2582f0ba0eb64fc3602527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad561a3c1f2582f0ba0eb64fc3602527">&#9670;&nbsp;</a></span>das_datum_toDbl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API double das_datum_toDbl </td>
          <td>(</td>
          <td class="paramtype">const das_datum *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a datum value as a double. </p>
<p>This function throws an error if the given datum is not convertable as a double value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The double value </dd></dl>

</div>
</div>
<a id="gafa1ed27e9726ec502b1cfc4c3d77fe45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa1ed27e9726ec502b1cfc4c3d77fe45">&#9670;&nbsp;</a></span>das_datum_toEpoch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_datum_toEpoch </td>
          <td>(</td>
          <td class="paramtype">const das_datum *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga69f5744c4a283544d36b64714e8b422d">das_units</a>&#160;</td>
          <td class="paramname"><em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a time datum value as a double at a given epoch an scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>pointer to the value to convert </td></tr>
    <tr><td class="paramname">units</td><td>The desired time base units, expects one of UNIT_US2000 and friends. Do not use UNIT_UTC, that's only ment for broken down time values. </td></tr>
    <tr><td class="paramname">pResult</td><td>Pointer to location to store the converted value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the conversion was successful, false otherwise and das_error is called. </dd></dl>

</div>
</div>
<a id="gabfce99e4553db5d18eb4bd450ee6c7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfce99e4553db5d18eb4bd450ee6c7aa">&#9670;&nbsp;</a></span>das_vt_fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const DAS_API void* das_vt_fill </td>
          <td>(</td>
          <td class="paramtype">das_val_type&#160;</td>
          <td class="paramname"><em>vt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default fill value for a given element type. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the default fill value, will have to cast to the appropriate type. </dd></dl>

</div>
</div>
<a id="ga97e987e793fd2aac803b7dda0ab5ed24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97e987e793fd2aac803b7dda0ab5ed24">&#9670;&nbsp;</a></span>das_vt_cmpAny()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API int das_vt_cmpAny </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">das_val_type&#160;</td>
          <td class="paramname"><em>vtA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">das_val_type&#160;</td>
          <td class="paramname"><em>vtB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare any two value types for equality. </p>
<p>If two types (vtA, vtB) are the same, memcmp is used. If two types are different the following promotion rules are applied.</p>
<ol type="1">
<li>Strings are never equal to non strings.</li>
<li>Since values have no units, times are never equal to non-times</li>
<li></li>
</ol>
<p>If either side is a vtByte, vtUShort, vtShort, vtInt, or vtFloat, vtDouble, both sides are promoted to double and compared.</p>
<dl class="section return"><dt>Returns</dt><dd>-1 if A is less than B, 0 if equal, +1 if A is greater than B or -2 if A is not comparable to B. </dd></dl>

</div>
</div>
<a id="gabd1179294ef2a637e4a585a8e9be8fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd1179294ef2a637e4a585a8e9be8fff">&#9670;&nbsp;</a></span>das_vt_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API das_val_type das_vt_merge </td>
          <td>(</td>
          <td class="paramtype">das_val_type&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">das_val_type&#160;</td>
          <td class="paramname"><em>left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>What would be the resulting type given an operation on the given value type. </p>
<p>Currently the binary type combining rules are:</p>
<ol type="1">
<li>Unknown combined with anything is unknown.</li>
<li>Index combined with anything is unknown.</li>
<li>ByteSeq combined with anything is unknown.</li>
<li>Text combined with anything is unknown.</li>
<li>Byte, UShort and Short math results in floats.</li>
<li>Int, Long, Float and Double math results in doubles.</li>
<li><p class="startli">If time in involved the following rules apply:</p>
<p class="startli">Time - Time = Double Time +/- (Byte, UShort, Short, Int, Float Double) =&gt; Time</p>
<p class="startli">All other operations invalving times are unknown</p>
</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td></td></tr>
    <tr><td class="paramname">op</td><td>An operation ID. </td></tr>
    <tr><td class="paramname">left</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting type or vtUnknown if the types cannot be combinded via any known operations </dd></dl>

</div>
</div>
<a id="ga53db8406b14aa454d2fc56048a27e0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53db8406b14aa454d2fc56048a27e0d7">&#9670;&nbsp;</a></span>das_str2double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_str2double </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string value to a 8-byte float, similar to strtod(3). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. Conversion stops at the first improper character. Whitespace and leading 0's are ignored in the input.</td></tr>
    <tr><td class="paramname">pRes</td><td>The location to store the resulting 8-byte float.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion succeeded, <code>false</code> otherwise. Among other reason, conversion will fail if the resulting value won't fit in a 8 byte float. </dd></dl>

</div>
</div>
<a id="ga56d10a5c35e5f09a46d9b9350b92ff56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56d10a5c35e5f09a46d9b9350b92ff56">&#9670;&nbsp;</a></span>das_str2int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_str2int </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the initial portion of a string to an integer with explicit over/underflow checks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. Conversion stops at the first improper character. Whitespace and leading 0's are ignored in the input. The number is assumed to be in base 10, unless the first non-whitespace characters after the optional '+' or '-' sign are '0x'.</td></tr>
    <tr><td class="paramname">pRes</td><td>The location to store the resulting integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion succeeded, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga224b6da8194ebb8bfe0f120ac6bf5ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga224b6da8194ebb8bfe0f120ac6bf5ddd">&#9670;&nbsp;</a></span>das_str2bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_str2bool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string value to a boolean value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. The following values are accepted as representing true: 'true' (any case), 'yes' (any case), 'T', 'Y', '1'. The following values are accepted as representing false: 'false' (any case), 'no', (any case), 'F', 'N', '0'. Anything else results in no conversion. </td></tr>
    <tr><td class="paramname">pRes</td><td>the location to store the resulting boolean value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the string could be converted to a boolean, false otherwise. </dd></dl>

</div>
</div>
<a id="ga55e7d6d83698b52a370aa7c55dc21958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55e7d6d83698b52a370aa7c55dc21958">&#9670;&nbsp;</a></span>das_str2baseint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_str2baseint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to an integer with explicit base and overflow checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. Conversion stops at the first improper character. Whitespace and leading 0's are ignored in the input. No assumptions are made about the base of the string. So anything that is not a proper character is the given base is causes an error return.</td></tr>
    <tr><td class="paramname">base</td><td>an integer from 1 to 60 inclusive.</td></tr>
    <tr><td class="paramname">pRes</td><td>The location to store the resulting integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion succeeded, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gadf95f28a7f862a7acb352cd2eeb13d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf95f28a7f862a7acb352cd2eeb13d61">&#9670;&nbsp;</a></span>das_strn2baseint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_strn2baseint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an explicit length string to an integer with explicit base with over/underflow checks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. Conversion stops at the first improper character. Whitespace and leading 0's are ignored in the input. No assumptions are made about the base of the string. So anything that is not a proper character is the given base is causes an error return.</td></tr>
    <tr><td class="paramname">base</td><td>an integer from 1 to 60 inclusive.</td></tr>
    <tr><td class="paramname">nLen</td><td>only look at up to this many characters of input. Encountering whitespace or a '\0' characater will still halt character accumlation.</td></tr>
    <tr><td class="paramname">pRes</td><td>The location to store the resulting integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion succeeded, <code>false</code> otherwise.</dd></dl>
<p>Will only inspect up to 64 non-whitespace characters when converting a value. </p>

</div>
</div>
<a id="ga48572b70b1f5dad97885532465270907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48572b70b1f5dad97885532465270907">&#9670;&nbsp;</a></span>das_csv2doubles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API double* das_csv2doubles </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nitems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a comma separated list of ASCII values into a double array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string of comma separated values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nitems</td><td>a pointer to an integer which will be set to the length of the newly allocated array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new double array allocated on the heap. </dd></dl>

</div>
</div>
<a id="gaded93ede3f543cbe20c6d143f47ff4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaded93ede3f543cbe20c6d143f47ff4b7">&#9670;&nbsp;</a></span>das_doubles2csv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API char* das_doubles2csv </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nitems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an array of doubles into a string buffer. </p>
<p>Prints an array of doubles into a string buffer with commas and spaces between each entry. Note there is no precision limit for the printing so the space needed to hold the array may 24 bytes times the number number of values, or more.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>this function is a potential source of buffer overruns, fix it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>a pointer to the buffer to receive the printed values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>an array of doubles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nitems</td><td>the number of items to print to the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the supplied buffer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
