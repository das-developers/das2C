<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>das2C: das2/util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="das2logo-32.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">das2C
   </div>
   <div id="projectbrief">das2 core C utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_abe7acac7957bd0645638cc092cd555a.html">das2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">util.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;<a class="el" href="defs_8h_source.html">das2/defs.h</a>&gt;</code><br />
</div>
<p><a href="util_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdas__error__message.html">das_error_message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure returned from das_get_error().  <a href="structdas__error__message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9ef9c28126d100b783969cb38705fe1c"><td class="memItemLeft" align="right" valign="top"><a id="a9ef9c28126d100b783969cb38705fe1c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9ef9c28126d100b783969cb38705fe1c">DASERR_DIS_EXIT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a9ef9c28126d100b783969cb38705fe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to indicate that errors should trigger program exit. <br /></td></tr>
<tr class="separator:a9ef9c28126d100b783969cb38705fe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e4971120478e0d74d5d7a2b23ee056"><td class="memItemLeft" align="right" valign="top"><a id="ad2e4971120478e0d74d5d7a2b23ee056"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad2e4971120478e0d74d5d7a2b23ee056">DASERR_DIS_RET</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ad2e4971120478e0d74d5d7a2b23ee056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to indicate that errors should trigger library functions to return error values. <br /></td></tr>
<tr class="separator:ad2e4971120478e0d74d5d7a2b23ee056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0f9548ba2f8f2d0921374be6fd9e21"><td class="memItemLeft" align="right" valign="top"><a id="a6a0f9548ba2f8f2d0921374be6fd9e21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a6a0f9548ba2f8f2d0921374be6fd9e21">DASERR_DIS_ABORT</a>&#160;&#160;&#160;43</td></tr>
<tr class="memdesc:a6a0f9548ba2f8f2d0921374be6fd9e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to indicate that errors should trigger program abort with a core dump. <br /></td></tr>
<tr class="separator:a6a0f9548ba2f8f2d0921374be6fd9e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d3985ce4e92bb37ac7bb45e9a2dd39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ac9d3985ce4e92bb37ac7bb45e9a2dd39">das_error</a>(nErrCode, ...)&#160;&#160;&#160;das_error_func(__FILE__, __func__, __LINE__, nErrCode, __VA_ARGS__ )</td></tr>
<tr class="memdesc:ac9d3985ce4e92bb37ac7bb45e9a2dd39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal an error condition.  <a href="util_8h.html#ac9d3985ce4e92bb37ac7bb45e9a2dd39">More...</a><br /></td></tr>
<tr class="separator:ac9d3985ce4e92bb37ac7bb45e9a2dd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabef7d61092376db8ddb6481392c9f19"><td class="memItemLeft" align="right" valign="top"><a id="aabef7d61092376db8ddb6481392c9f19"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aabef7d61092376db8ddb6481392c9f19">das_within</a>(A,  B,  E)&#160;&#160;&#160;(fabs(A - B) &lt; E ? true : false)</td></tr>
<tr class="memdesc:aabef7d61092376db8ddb6481392c9f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if two floating point values are within an epsilon of each other. <br /></td></tr>
<tr class="separator:aabef7d61092376db8ddb6481392c9f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261adfadcb579caea6918a60a8967ebc"><td class="memItemLeft" align="right" valign="top"><a id="a261adfadcb579caea6918a60a8967ebc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a261adfadcb579caea6918a60a8967ebc">DAS_XML_MAXPROPS</a>&#160;&#160;&#160;400</td></tr>
<tr class="memdesc:a261adfadcb579caea6918a60a8967ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">limit of number of properties per descriptor. <br /></td></tr>
<tr class="separator:a261adfadcb579caea6918a60a8967ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c9fa13b5f1eda73f6ff528327139b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ab4c9fa13b5f1eda73f6ff528327139b7">DAS_XML_BUF_LEN</a>&#160;&#160;&#160;1000000</td></tr>
<tr class="memdesc:ab4c9fa13b5f1eda73f6ff528327139b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The limit on xml packet length, in bytes.  <a href="util_8h.html#ab4c9fa13b5f1eda73f6ff528327139b7">More...</a><br /></td></tr>
<tr class="separator:ab4c9fa13b5f1eda73f6ff528327139b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1f44d42d0663329ac249b554970e8c"><td class="memItemLeft" align="right" valign="top"><a id="aab1f44d42d0663329ac249b554970e8c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aab1f44d42d0663329ac249b554970e8c">DAS_XML_NODE_NAME_LEN</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:aab1f44d42d0663329ac249b554970e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The limit of xml element name length, in bytes. <br /></td></tr>
<tr class="separator:aab1f44d42d0663329ac249b554970e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156e995419bf1b45762947deb7f5b291"><td class="memItemLeft" align="right" valign="top"><a id="a156e995419bf1b45762947deb7f5b291"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a156e995419bf1b45762947deb7f5b291">DAS_MAX_ID_BUFSZ</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:a156e995419bf1b45762947deb7f5b291"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of an char buffer large enough to hold valid object IDs. <br /></td></tr>
<tr class="separator:a156e995419bf1b45762947deb7f5b291"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a19b1f13596c64efdfca4e3e3048b2888"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a19b1f13596c64efdfca4e3e3048b2888">das_log_handler_t</a>) (int nLevel, const char *sMsg, bool bPrnTime)</td></tr>
<tr class="memdesc:a19b1f13596c64efdfca4e3e3048b2888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a message handler function pointer.  <a href="util_8h.html#a19b1f13596c64efdfca4e3e3048b2888">More...</a><br /></td></tr>
<tr class="separator:a19b1f13596c64efdfca4e3e3048b2888"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab73de5e20047e7e8f6d6ec8416ea1bdb"><td class="memItemLeft" align="right" valign="top">DAS_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ab73de5e20047e7e8f6d6ec8416ea1bdb">das_init</a> (const char *sProgName, int nErrDis, int nErrBufSz, int nLevel, <a class="el" href="util_8h.html#a19b1f13596c64efdfca4e3e3048b2888">das_log_handler_t</a> logfunc)</td></tr>
<tr class="memdesc:ab73de5e20047e7e8f6d6ec8416ea1bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize any global structures in the Das2 library.  <a href="util_8h.html#ab73de5e20047e7e8f6d6ec8416ea1bdb">More...</a><br /></td></tr>
<tr class="separator:ab73de5e20047e7e8f6d6ec8416ea1bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c634640d060218d3a34dc274aa1cd9e"><td class="memItemLeft" align="right" valign="top"><a id="a7c634640d060218d3a34dc274aa1cd9e"></a>
DAS_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7c634640d060218d3a34dc274aa1cd9e">das_finish</a> (void)</td></tr>
<tr class="memdesc:a7c634640d060218d3a34dc274aa1cd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A do nothing function on Unix, closes network sockets on windows. <br /></td></tr>
<tr class="separator:a7c634640d060218d3a34dc274aa1cd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9853105d6652b04c611bc1d9139b5bf6"><td class="memItemLeft" align="right" valign="top">DAS_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9853105d6652b04c611bc1d9139b5bf6">das_abort_on_error</a> (void)</td></tr>
<tr class="memdesc:a9853105d6652b04c611bc1d9139b5bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling: Trigger Core Dumps.  <a href="util_8h.html#a9853105d6652b04c611bc1d9139b5bf6">More...</a><br /></td></tr>
<tr class="separator:a9853105d6652b04c611bc1d9139b5bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1968d84cd3cc04bd72a89159a5276e1"><td class="memItemLeft" align="right" valign="top">DAS_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ae1968d84cd3cc04bd72a89159a5276e1">das_exit_on_error</a> (void)</td></tr>
<tr class="memdesc:ae1968d84cd3cc04bd72a89159a5276e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling: Normal Exit Set the library to call exit(ErrorCode) when a problem is detected.  <a href="util_8h.html#ae1968d84cd3cc04bd72a89159a5276e1">More...</a><br /></td></tr>
<tr class="separator:ae1968d84cd3cc04bd72a89159a5276e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a71b3da68fed9ad3a2a28e9633eb1f3"><td class="memItemLeft" align="right" valign="top">DAS_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a4a71b3da68fed9ad3a2a28e9633eb1f3">das_return_on_error</a> (void)</td></tr>
<tr class="memdesc:a4a71b3da68fed9ad3a2a28e9633eb1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling: Normal Return Set the library to return normally to the calling function with a return value that indicates a problem has occurred.  <a href="util_8h.html#a4a71b3da68fed9ad3a2a28e9633eb1f3">More...</a><br /></td></tr>
<tr class="separator:a4a71b3da68fed9ad3a2a28e9633eb1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c094e9f194f5b1bb6c5e27753832899"><td class="memItemLeft" align="right" valign="top">DAS_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a3c094e9f194f5b1bb6c5e27753832899">das_error_disposition</a> (void)</td></tr>
<tr class="memdesc:a3c094e9f194f5b1bb6c5e27753832899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling: get the library's error disposition.  <a href="util_8h.html#a3c094e9f194f5b1bb6c5e27753832899">More...</a><br /></td></tr>
<tr class="separator:a3c094e9f194f5b1bb6c5e27753832899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8747f75b5ad5a11206f2dfb647639c12"><td class="memItemLeft" align="right" valign="top">DAS_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a8747f75b5ad5a11206f2dfb647639c12">das_print_error</a> (void)</td></tr>
<tr class="memdesc:a8747f75b5ad5a11206f2dfb647639c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling: Print formatted error to standard error stream Set the library to ouput formatted error messages to the processes standard error stream.  <a href="util_8h.html#a8747f75b5ad5a11206f2dfb647639c12">More...</a><br /></td></tr>
<tr class="separator:a8747f75b5ad5a11206f2dfb647639c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fefee18c18621756a88055560d9c5d"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ab8fefee18c18621756a88055560d9c5d">das_save_error</a> (int maxmsg)</td></tr>
<tr class="memdesc:ab8fefee18c18621756a88055560d9c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling: Save formatted error in a message buffer.  <a href="util_8h.html#ab8fefee18c18621756a88055560d9c5d">More...</a><br /></td></tr>
<tr class="separator:ab8fefee18c18621756a88055560d9c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bea1c4e22f2febecf9e8f8035bf4b9"><td class="memItemLeft" align="right" valign="top">const DAS_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a18bea1c4e22f2febecf9e8f8035bf4b9">das_lib_version</a> (void)</td></tr>
<tr class="memdesc:a18bea1c4e22f2febecf9e8f8035bf4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the library version.  <a href="util_8h.html#a18bea1c4e22f2febecf9e8f8035bf4b9">More...</a><br /></td></tr>
<tr class="separator:a18bea1c4e22f2febecf9e8f8035bf4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d621cde2473119ce716553bb289227"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a83d621cde2473119ce716553bb289227">das_assert_valid_id</a> (const char *sId)</td></tr>
<tr class="memdesc:a83d621cde2473119ce716553bb289227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that a string is suitable for use as an object ID.  <a href="util_8h.html#a83d621cde2473119ce716553bb289227">More...</a><br /></td></tr>
<tr class="separator:a83d621cde2473119ce716553bb289227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd6632ef81801162b58b0b9cf98d4cb"><td class="memItemLeft" align="right" valign="top">DAS_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a8dd6632ef81801162b58b0b9cf98d4cb">das_store_str</a> (char **psDest, size_t *puLen, const char *sSrc)</td></tr>
<tr class="memdesc:a8dd6632ef81801162b58b0b9cf98d4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store string in a buffer that is reallocated if need be.  <a href="util_8h.html#a8dd6632ef81801162b58b0b9cf98d4cb">More...</a><br /></td></tr>
<tr class="separator:a8dd6632ef81801162b58b0b9cf98d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c5f9bed71fcbf353d12543ddae0053"><td class="memItemLeft" align="right" valign="top">DAS_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a51c5f9bed71fcbf353d12543ddae0053">das_string</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:a51c5f9bed71fcbf353d12543ddae0053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new string on the heap and format it.  <a href="util_8h.html#a51c5f9bed71fcbf353d12543ddae0053">More...</a><br /></td></tr>
<tr class="separator:a51c5f9bed71fcbf353d12543ddae0053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6635bbb24a0e4112fdded61733021d3c"><td class="memItemLeft" align="right" valign="top">DAS_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a6635bbb24a0e4112fdded61733021d3c">das_strdup</a> (const char *sIn)</td></tr>
<tr class="memdesc:a6635bbb24a0e4112fdded61733021d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string into a new buffer allocated on the heap.  <a href="util_8h.html#a6635bbb24a0e4112fdded61733021d3c">More...</a><br /></td></tr>
<tr class="separator:a6635bbb24a0e4112fdded61733021d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0768e164a15389b1c1ff293767a570"><td class="memItemLeft" align="right" valign="top">DAS_API uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a3a0768e164a15389b1c1ff293767a570">das_memset</a> (uint8_t *pDest, const uint8_t *pSrc, size_t uElemSz, size_t uCount)</td></tr>
<tr class="memdesc:a3a0768e164a15389b1c1ff293767a570"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memset that handles multi-byte items <br  />
  <a href="util_8h.html#a3a0768e164a15389b1c1ff293767a570">More...</a><br /></td></tr>
<tr class="separator:a3a0768e164a15389b1c1ff293767a570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f750e1f86200d5b5ae8e1f4cc1577b6"><td class="memItemLeft" align="right" valign="top">DAS_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a8f750e1f86200d5b5ae8e1f4cc1577b6">das_vstring</a> (const char *fmt, va_list ap)</td></tr>
<tr class="memdesc:a8f750e1f86200d5b5ae8e1f4cc1577b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a formatted string in a newly allocated buffer.  <a href="util_8h.html#a8f750e1f86200d5b5ae8e1f4cc1577b6">More...</a><br /></td></tr>
<tr class="separator:a8f750e1f86200d5b5ae8e1f4cc1577b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731d2aad2fa189a476b42451e060c20a"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a731d2aad2fa189a476b42451e060c20a">das_isdir</a> (const char *path)</td></tr>
<tr class="memdesc:a731d2aad2fa189a476b42451e060c20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the path a directory.  <a href="util_8h.html#a731d2aad2fa189a476b42451e060c20a">More...</a><br /></td></tr>
<tr class="separator:a731d2aad2fa189a476b42451e060c20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8500c4a85721259b0bfd719d5fbb151"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad8500c4a85721259b0bfd719d5fbb151">das_copyfile</a> (const char *src, const char *dest, mode_t mode)</td></tr>
<tr class="memdesc:ad8500c4a85721259b0bfd719d5fbb151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a file to a distination creating directories as needed.  <a href="util_8h.html#ad8500c4a85721259b0bfd719d5fbb151">More...</a><br /></td></tr>
<tr class="separator:ad8500c4a85721259b0bfd719d5fbb151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aec9fbee17540e492af306e0b10158f"><td class="memItemLeft" align="right" valign="top">DAS_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a1aec9fbee17540e492af306e0b10158f">das_isfile</a> (const char *path)</td></tr>
<tr class="memdesc:a1aec9fbee17540e492af306e0b10158f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the path a file.  <a href="util_8h.html#a1aec9fbee17540e492af306e0b10158f">More...</a><br /></td></tr>
<tr class="separator:a1aec9fbee17540e492af306e0b10158f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e22b7620f04f28d302be1894db2f8b"><td class="memItemLeft" align="right" valign="top">DAS_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a77e22b7620f04f28d302be1894db2f8b">das_dirlist</a> (const char *sPath, char ppDirList[][256], size_t uMaxDirs, char cType)</td></tr>
<tr class="memdesc:a77e22b7620f04f28d302be1894db2f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sorted directory listing.  <a href="util_8h.html#a77e22b7620f04f28d302be1894db2f8b">More...</a><br /></td></tr>
<tr class="separator:a77e22b7620f04f28d302be1894db2f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac9d3985ce4e92bb37ac7bb45e9a2dd39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d3985ce4e92bb37ac7bb45e9a2dd39">&#9670;&nbsp;</a></span>das_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define das_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nErrCode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;das_error_func(__FILE__, __func__, __LINE__, nErrCode, __VA_ARGS__ )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal an error condition. </p>
<p>This routine is called throughout the code when an error condition arrises.</p>
<p>The default handler for error conditions prints the message provided to the standard error channel and then calls exit(nErrCode). To have the library call your handler instead use the das_set_error_handler() function. To have the library abort with a core dump on an error use <a class="el" href="util_8h.html#a9853105d6652b04c611bc1d9139b5bf6" title="Error handling: Trigger Core Dumps.">das_abort_on_error()</a>.</p>
<p>Each source file in the code has it's own error code. Though it's probably not that useful to end users, the codes are provided here:</p>
<ul>
<li><b>8</b> : Not yet implemented - DASERR_NOTIMP</li>
<li><b>9</b> : Assertion Failures - DASERR_ASSERT</li>
<li><b>10</b> : das1.c - D1ERR</li>
<li><b>11</b> : Lib initialization errors - DASERR_INIT</li>
<li><b>12</b> : buffer.c - DASERR_BUF <br  />
</li>
<li><b>13</b> : util.c - DASERR_UTIL <br  />
</li>
<li><b>14</b> : encoding.c - DASERR_ENC <br  />
</li>
<li><b>15</b> : units.c - DASERR_UNITS <br  />
</li>
<li><b>16</b> : descriptor.c - DASERR_DESC <br  />
</li>
<li><b>17</b> : plane.c - DASERR_PLANE <br  />
</li>
<li><b>18</b> : packet.c - DASERR_PKT <br  />
</li>
<li><b>19</b> : stream.c - DASERR_STREAM</li>
<li><b>20</b> : oob.c - DASERR_OOB <br  />
</li>
<li><b>21</b> : io.c - DASERR_IO <br  />
</li>
<li><b>22</b> : dsdf.c - DASERR_DSDF <br  />
</li>
<li><b>23</b> : dft.c - DASERR_DFT <br  />
</li>
<li><b>24</b> : log.c - DASERR_LOG <br  />
</li>
<li><b>25</b> : array.c - DASERR_ARRAY <br  />
</li>
<li><b>26</b> : variable.c - DASERR_VAR <br  />
</li>
<li><b>27</b> : dimension.c - DASERR_DIM <br  />
</li>
<li><b>28</b> : dataset.c - DASERR_DS <br  />
</li>
<li><b>29</b> : builder.c - DASERR_BLDR <br  />
</li>
<li><b>30</b> : http.c - DASERR_HTTP <br  />
</li>
<li><b>31</b> : datum.c - DASERR_DATUM <br  />
</li>
<li><b>32</b> : value.c - DASERR_VALUE <br  />
</li>
<li><b>34</b> : operater.c - DASERR_OP</li>
<li><b>35</b> : credentials.c - DASERR_CRED</li>
<li><b>36</b> : catalog.c - DASERR_CAT</li>
</ul>
<p>Application programs are recommended to use values 64 and above to avoid colliding with future das2 error codes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nErrCode</td><td>The value to return to the shell, should be one of the above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>By default this function never returns but if the libdas2 error disposition has been set to DAS2_ERRDIS_RET then the value of nErrCode is returned. </dd></dl>

</div>
</div>
<a id="ab4c9fa13b5f1eda73f6ff528327139b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c9fa13b5f1eda73f6ff528327139b7">&#9670;&nbsp;</a></span>DAS_XML_BUF_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DAS_XML_BUF_LEN&#160;&#160;&#160;1000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The limit on xml packet length, in bytes. </p>
<p>(ascii encoding.) </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a19b1f13596c64efdfca4e3e3048b2888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b1f13596c64efdfca4e3e3048b2888">&#9670;&nbsp;</a></span>das_log_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* das_log_handler_t) (int nLevel, const char *sMsg, bool bPrnTime)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of a message handler function pointer. </p>
<p>Message handlers need to be prepared for any of the string pointers sMsg, sDataStatus, or sStackTrace to be null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nLevel</td><td>The message level. If nLevel is equal to or greater than das_log_getlevel() then the message should be logged.</td></tr>
    <tr><td class="paramname">sMsg</td><td>The message, usually not null.</td></tr>
    <tr><td class="paramname">bPrnTime</td><td>The current system time should be included in the log output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab73de5e20047e7e8f6d6ec8416ea1bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73de5e20047e7e8f6d6ec8416ea1bdb">&#9670;&nbsp;</a></span>das_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API void das_init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sProgName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nErrDis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nErrBufSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a19b1f13596c64efdfca4e3e3048b2888">das_log_handler_t</a>&#160;</td>
          <td class="paramname"><em>logfunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize any global structures in the Das2 library. </p>
<p>This should be the first function your program calls before using any libdas2 functions. In general libdas2 tries to avoid global structures but does use them in following areas:</p>
<ul>
<li>Error and log handling - Since the error and logging disposition should be the same for all library calls handlers are set here</li>
<li>Unit conversions - Since das_unit varibles should be comparible using a simple equality test, a global registry of const char pointers is needed</li>
<li>TT2000 leapsecond table - To avoid rebuilding the library after each leapsocond is announced, an external table defined by the environment variable CDF_LEAPSECONDTABLE is loaded, if the variable is defined.</li>
<li>FFTW plan mutexes - Since the FFTW library unfortunatly uses global plan memory</li>
<li>OpenSSL Contex mutexes - The openssl library contex cannot be changed by multiple threads at the same time, a mutex is setup to prevent this from happening</li>
</ul>
<p>This function initializes defaults for the items above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sProgName</td><td>The name of the program using the library. Used in some error messages.</td></tr>
    <tr><td class="paramname">nErrDis</td><td>Set the behavior the library takes when an error is encountered. May be one of DASERR_DIS_EXIT, call exit() when an error occurs; DASERR_DIS_RET, return with an error code; or DASERR_DIS_ABORT, call abort(). The value of DASERR_DIS_EXIT is 0 so you can use that for the default behavior. If DASERR_DIS_RET is used, the function das_get_error() can be used to retrieve the most recent error message.</td></tr>
    <tr><td class="paramname">nErrBufSz</td><td>If not zero, a global error message buffer will be allocated that is this many bytes long and error message will be saved into the buffer instead of being sent to the standard error channel. Messages can be retrieved via das_get_error(). If zero, these will be send to the standard error channel as soon as they occur. Saving errors is only useful if the error disposition is DAS2_ERRDIS_RET as otherwise the program exits before the message can be output.</td></tr>
    <tr><td class="paramname">nLevel</td><td>Set the logging level to one of, DASLOG_TRACE, DASLOG_DEBUG, DASLOG_NOTICE, DASLOG_WARN, DASLOG_ERROR, DASLOG_CRITICAL.</td></tr>
    <tr><td class="paramname">logfunc</td><td>A callback for handling log messages. The callback need not be thread safe as it will only be triggered inside mutual exclusion (mutex) locks. If NULL messages are printed to the stardard error channel.</td></tr>
  </table>
  </dd>
</dl>
<p>The error disposition does not affect any errors that are encountered within das_init. Errors should not occur during initialization, any that do trigger a call to exit() </p>

</div>
</div>
<a id="a9853105d6652b04c611bc1d9139b5bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9853105d6652b04c611bc1d9139b5bf6">&#9670;&nbsp;</a></span>das_abort_on_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API void das_abort_on_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handling: Trigger Core Dumps. </p>
<p>Call this function to have the library exit via an abort() call instead of using exit(ErrorCode). On most systems this will trigger the generation of a core file that can be used for debugging. </p><dl class="section warning"><dt>Warning</dt><dd>: Calling this function prevents open file handles from being flushed to disk which will typically result in corrupted output. </dd></dl>

</div>
</div>
<a id="ae1968d84cd3cc04bd72a89159a5276e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1968d84cd3cc04bd72a89159a5276e1">&#9670;&nbsp;</a></span>das_exit_on_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API void das_exit_on_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handling: Normal Exit Set the library to call exit(ErrorCode) when a problem is detected. </p>
<p>This is usually what you want and the library's default setting. </p>

</div>
</div>
<a id="a4a71b3da68fed9ad3a2a28e9633eb1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a71b3da68fed9ad3a2a28e9633eb1f3">&#9670;&nbsp;</a></span>das_return_on_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API void das_return_on_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handling: Normal Return Set the library to return normally to the calling function with a return value that indicates a problem has occurred. </p>
<p>This will be the new default, but is not yet tested. </p>

</div>
</div>
<a id="a3c094e9f194f5b1bb6c5e27753832899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c094e9f194f5b1bb6c5e27753832899">&#9670;&nbsp;</a></span>das_error_disposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API int das_error_disposition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handling: get the library's error disposition. </p>
<dl class="section return"><dt>Returns</dt><dd>one of the following integers:<ul>
<li>DAS2_ERRDIS_EXIT - Library exits when there is a problem</li>
<li>DAS2_ERRDIS_ABORT - Library aborts, possibly with core dump on a problem</li>
<li>DAS2_ERRDIS_RET - Library returns normally with an error code </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8747f75b5ad5a11206f2dfb647639c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8747f75b5ad5a11206f2dfb647639c12">&#9670;&nbsp;</a></span>das_print_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API void das_print_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handling: Print formatted error to standard error stream Set the library to ouput formatted error messages to the processes standard error stream. </p>
<p>This is the default. </p>

</div>
</div>
<a id="ab8fefee18c18621756a88055560d9c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fefee18c18621756a88055560d9c5d">&#9670;&nbsp;</a></span>das_save_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_save_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handling: Save formatted error in a message buffer. </p>
<p>Set the library to save formatted error message to a message buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxmsg</td><td>maximum message size. The buffer created will be maxmsg in length, meaning any formatted messages longer than the available buffer size will be truncated to maxmsg-1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if error buffer setup was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a18bea1c4e22f2febecf9e8f8035bf4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18bea1c4e22f2febecf9e8f8035bf4b9">&#9670;&nbsp;</a></span>das_lib_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const DAS_API char* das_lib_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the library version. </p>
<dl class="section return"><dt>Returns</dt><dd>the version tag string for the das2 core library, or the string "untagged" if the version is unknown </dd></dl>

</div>
</div>
<a id="a83d621cde2473119ce716553bb289227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d621cde2473119ce716553bb289227">&#9670;&nbsp;</a></span>das_assert_valid_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_assert_valid_id </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that a string is suitable for use as an object ID. </p>
<p>Object ID strings are ascii strings using only characters from the set a-z, A-Z, 0-9, and _. They do not start with a number. They are no more than 63 bytes long. Basically they can be used as variable names in most programming languages.</p>
<p>If the das_error_disposition is set to exit this function never returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sId</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string can be used as an ID, false otherwise. </dd></dl>

</div>
</div>
<a id="a8dd6632ef81801162b58b0b9cf98d4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd6632ef81801162b58b0b9cf98d4cb">&#9670;&nbsp;</a></span>das_store_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API void das_store_str </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>psDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>puLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store string in a buffer that is reallocated if need be. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDest</td><td>a pointer to the storage location </td></tr>
    <tr><td class="paramname">puLen</td><td>a pointer to the size of the storage location </td></tr>
    <tr><td class="paramname">sSrc</td><td>the source string to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51c5f9bed71fcbf353d12543ddae0053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c5f9bed71fcbf353d12543ddae0053">&#9670;&nbsp;</a></span>das_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API char* das_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new string on the heap and format it. </p>
<p>Except for using das_error on a failure, this is a copy of the code out of man 3 printf on Linux.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated and formatted string on the heap, or NULL if the function failed and the das2 error disposition allows for continuation after a failure </dd></dl>

</div>
</div>
<a id="a6635bbb24a0e4112fdded61733021d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6635bbb24a0e4112fdded61733021d3c">&#9670;&nbsp;</a></span>das_strdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API char* das_strdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string into a new buffer allocated on the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sIn</td><td>the string to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated buffer containing the same characters as the input string or NULL if the input length was zero </dd></dl>

</div>
</div>
<a id="a3a0768e164a15389b1c1ff293767a570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0768e164a15389b1c1ff293767a570">&#9670;&nbsp;</a></span>das_memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API uint8_t* das_memset </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uElemSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A memset that handles multi-byte items <br  />
 </p>
<p>Uses memcpy because the amount of data written in each call goes up exponentially and memcpy is freaking fast, much faster than a linear write loop for large arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDest</td><td>The destination area must not overlap with pSrc </td></tr>
    <tr><td class="paramname">pSrc</td><td>A location for an individual element to repeat in pDest </td></tr>
    <tr><td class="paramname">uElemSz</td><td>The size in bytes of a single element </td></tr>
    <tr><td class="paramname">uCount</td><td>The number of elements to repeat in pDest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input pDest pointer. There is no provision for a NULL return as this function should not fail since the memory is pre-allocated by the caller </dd></dl>

</div>
</div>
<a id="a8f750e1f86200d5b5ae8e1f4cc1577b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f750e1f86200d5b5ae8e1f4cc1577b6">&#9670;&nbsp;</a></span>das_vstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API char* das_vstring </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a formatted string in a newly allocated buffer. </p>
<p>This version is suitable for calling from variable argument functions.</p>
<p>Except for using das_error on a failure, this is a copy of the code out of man 3 printf on Linux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>- a printf format string </td></tr>
    <tr><td class="paramname">ap</td><td>A va_list list, see vfprintf or stdarg.h for details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated and formatted string on the heap, or NULL if the function failed and the das2 error disposition allows for continuation after a failure </dd></dl>

</div>
</div>
<a id="a731d2aad2fa189a476b42451e060c20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731d2aad2fa189a476b42451e060c20a">&#9670;&nbsp;</a></span>das_isdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_isdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the path a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The directory in question, passed to stat(2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <b>path</b> can be determined to be a directory, false otherwise </dd></dl>

</div>
</div>
<a id="ad8500c4a85721259b0bfd719d5fbb151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8500c4a85721259b0bfd719d5fbb151">&#9670;&nbsp;</a></span>das_copyfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_copyfile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a file to a distination creating directories as needed. </p>
<p>If the files exists at the destination it in overwritten. Directories are created as needed. Directory permissions are are the same as the file with the addition that for each READ permission in the mode, directory EXEC permission is added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>- name of file to copy </td></tr>
    <tr><td class="paramname">dest</td><td>- name of destination </td></tr>
    <tr><td class="paramname">mode</td><td>- the permission mode of the destitation file, 0664 is recommened if you can descide on the output permissions mode. (mode argument not present in WIN32 version)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- true if the copy was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a1aec9fbee17540e492af306e0b10158f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aec9fbee17540e492af306e0b10158f">&#9670;&nbsp;</a></span>das_isfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API bool das_isfile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the path a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file in question, passed to stat(2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <b>path</b> can be determined to be a file, false otherwise </dd></dl>

</div>
</div>
<a id="a77e22b7620f04f28d302be1894db2f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e22b7620f04f28d302be1894db2f8b">&#9670;&nbsp;</a></span>das_dirlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DAS_API int das_dirlist </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ppDirList</em>[][256], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uMaxDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>cType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a sorted directory listing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sPath</td><td>The path to the directory to read.</td></tr>
    <tr><td class="paramname">ppDirList</td><td>A pointer to a 2-D character array where the first index is the directory item and the second index is the character position. The max value of the second index <b>must</b> be = NAME_MAX - 1. The value NAME_MAX is defined in the POSIX header limits.h</td></tr>
    <tr><td class="paramname">uMaxDirs</td><td>The maximum number of directory entries that may be stored<ul>
<li></li>
</ul>
</td></tr>
    <tr><td class="paramname">cType</td><td>May be used to filter the items returned. If cType = 'f' only files will be return, if cType = 'd' then only directories will be returned. Any other value, including 0 will return both.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success the number of items in the directory not counting '.' and '..' are returned, on failure a negative error code is returned. Item names are sorted before return. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
