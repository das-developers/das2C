<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libdas2: Datasets</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="das2logo-32.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">libdas2
   </div>
   <div id="projectbrief">das2 core C utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Datasets</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classes and functions for storing and manipulating correlated data values.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Classes and functions for storing and manipulating correlated data values. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html">DasAry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic recursive ragged arrays.  <a href="structDasAry.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDs.html">DasDs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Das2 Datasets.  <a href="structDasDs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdasds__iterator.html">dasds_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dataset iterator structure.  <a href="structdasds__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDim.html">DasDim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Das2 Physical Dimensions.  <a href="structDasDim.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasVar.html">DasVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Das2 fexible variables.  <a href="structDasVar.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBuilder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds datasets from a das2 stream.  <a href="classBuilder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6f80b145684c4ea36285e04cfe1a5ac1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f80b145684c4ea36285e04cfe1a5ac1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga6f80b145684c4ea36285e04cfe1a5ac1">DasDs_rank</a>(P)&#160;&#160;&#160;P-&gt;nRank</td></tr>
<tr class="memdesc:ga6f80b145684c4ea36285e04cfe1a5ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank of a dataset. <br/></td></tr>
<tr class="separator:ga6f80b145684c4ea36285e04cfe1a5ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab1ad242b3b37d4b5ef491a5d9df614e4"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gab1ad242b3b37d4b5ef491a5d9df614e4">DasDs_lengthIn</a> (const <a class="el" href="structDasDs.html">DasDs</a> *pThis, int nIdx, ptrdiff_t *pLoc)</td></tr>
<tr class="memdesc:gab1ad242b3b37d4b5ef491a5d9df614e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current max value index value + 1 for any partial index.  <a href="#gab1ad242b3b37d4b5ef491a5d9df614e4">More...</a><br/></td></tr>
<tr class="separator:gab1ad242b3b37d4b5ef491a5d9df614e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88fb0e6591ff9d290529ea35ef9e9e06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga88fb0e6591ff9d290529ea35ef9e9e06">DasDs_copyInProps</a> (<a class="el" href="structDasDs.html">DasDs</a> *pThis, const <a class="el" href="structDasDesc.html">DasDesc</a> *pOther)</td></tr>
<tr class="memdesc:ga88fb0e6591ff9d290529ea35ef9e9e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy in dataset properties from some other descriptor.  <a href="#ga88fb0e6591ff9d290529ea35ef9e9e06">More...</a><br/></td></tr>
<tr class="separator:ga88fb0e6591ff9d290529ea35ef9e9e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76625550faffb01559e9e6e05cfbdd4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gaf76625550faffb01559e9e6e05cfbdd4">DasDs_toStr</a> (const <a class="el" href="structDasDs.html">DasDs</a> *pThis, char *sBuf, int nLen)</td></tr>
<tr class="memdesc:gaf76625550faffb01559e9e6e05cfbdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a string reprenestation of this dataset.  <a href="#gaf76625550faffb01559e9e6e05cfbdd4">More...</a><br/></td></tr>
<tr class="separator:gaf76625550faffb01559e9e6e05cfbdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd7d415f4404c3d2c1388eaeb31944e"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gadcd7d415f4404c3d2c1388eaeb31944e">DasDim_lengthIn</a> (const <a class="el" href="structDasDim.html">DasDim</a> *pThis, int nIdx, ptrdiff_t *pLoc)</td></tr>
<tr class="memdesc:gadcd7d415f4404c3d2c1388eaeb31944e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current max value index value + 1 for any partial index.  <a href="#gadcd7d415f4404c3d2c1388eaeb31944e">More...</a><br/></td></tr>
<tr class="separator:gadcd7d415f4404c3d2c1388eaeb31944e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7147e064f00b1aeaf8c9f163d492dc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gae7147e064f00b1aeaf8c9f163d492dc9">das_op_unary</a> (const char *sOp)</td></tr>
<tr class="memdesc:gae7147e064f00b1aeaf8c9f163d492dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string into a unary operator token.  <a href="#gae7147e064f00b1aeaf8c9f163d492dc9">More...</a><br/></td></tr>
<tr class="separator:gae7147e064f00b1aeaf8c9f163d492dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ddf7d68e0adc463548fbec76affa25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga57ddf7d68e0adc463548fbec76affa25">das_op_binary</a> (const char *sOp)</td></tr>
<tr class="memdesc:ga57ddf7d68e0adc463548fbec76affa25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string into a binary operator token.  <a href="#ga57ddf7d68e0adc463548fbec76affa25">More...</a><br/></td></tr>
<tr class="separator:ga57ddf7d68e0adc463548fbec76affa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga279ce76e2f8deaf2d50fb47c864b9160"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga279ce76e2f8deaf2d50fb47c864b9160">das_op_toStr</a> (int nOp, int *pos)</td></tr>
<tr class="memdesc:ga279ce76e2f8deaf2d50fb47c864b9160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a string representation of an operator token and an indication of where the operator normally appears.  <a href="#ga279ce76e2f8deaf2d50fb47c864b9160">More...</a><br/></td></tr>
<tr class="separator:ga279ce76e2f8deaf2d50fb47c864b9160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfd6731b42c411e853ae384cb0fda693"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabfd6731b42c411e853ae384cb0fda693"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gabfd6731b42c411e853ae384cb0fda693">das_op_isBinary</a> (int nOp)</td></tr>
<tr class="memdesc:gabfd6731b42c411e853ae384cb0fda693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a binary operation, false otherwise. <br/></td></tr>
<tr class="separator:gabfd6731b42c411e853ae384cb0fda693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f64553008a53b193e1ca484f3664232"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f64553008a53b193e1ca484f3664232"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga1f64553008a53b193e1ca484f3664232">das_op_isUnary</a> (int nOp)</td></tr>
<tr class="memdesc:ga1f64553008a53b193e1ca484f3664232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if op is a unary operation, false otherwise. <br/></td></tr>
<tr class="separator:ga1f64553008a53b193e1ca484f3664232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb45a6ca58ed1754dcfabe85f5816bb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb45a6ca58ed1754dcfabe85f5816bb6"></a>
<a class="el" href="structDasVar.html">DasVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gabb45a6ca58ed1754dcfabe85f5816bb6">new_DasVarEval</a> (const <a class="el" href="structDasVar.html">DasVar</a> *pVar)</td></tr>
<tr class="memdesc:gabb45a6ca58ed1754dcfabe85f5816bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate all sub-variable expressions and a single array variable. <br/></td></tr>
<tr class="separator:gabb45a6ca58ed1754dcfabe85f5816bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4ff1c2981bb42fb83fb55c6a8c87b57"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gaa4ff1c2981bb42fb83fb55c6a8c87b57">DasVar_lengthIn</a> (const <a class="el" href="structDasVar.html">DasVar</a> *pThis, int nIdx, ptrdiff_t *pLoc)</td></tr>
<tr class="memdesc:gaa4ff1c2981bb42fb83fb55c6a8c87b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current max value index value + 1 for any partial index.  <a href="#gaa4ff1c2981bb42fb83fb55c6a8c87b57">More...</a><br/></td></tr>
<tr class="separator:gaa4ff1c2981bb42fb83fb55c6a8c87b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768190231541563b83fa766fd57210fd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga768190231541563b83fa766fd57210fd">DasVar_toStr</a> (const <a class="el" href="structDasVar.html">DasVar</a> *pThis, char *sBuf, int nLen)</td></tr>
<tr class="memdesc:ga768190231541563b83fa766fd57210fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string representation of this variable.  <a href="#ga768190231541563b83fa766fd57210fd">More...</a><br/></td></tr>
<tr class="separator:ga768190231541563b83fa766fd57210fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1a467a4ea3c7bd859b6b8acccdbc579"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasDs.html">DasDs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gad1a467a4ea3c7bd859b6b8acccdbc579">new_DasDs</a> (const char *sId, const char *sGroupId, int nRank)</td></tr>
<tr class="memdesc:gad1a467a4ea3c7bd859b6b8acccdbc579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dataset object.  <a href="#gad1a467a4ea3c7bd859b6b8acccdbc579">More...</a><br/></td></tr>
<tr class="separator:gad1a467a4ea3c7bd859b6b8acccdbc579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6f1b5169818bd92f98a01a964682f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga3e6f1b5169818bd92f98a01a964682f2">del_DasDs</a> (<a class="el" href="structDasDs.html">DasDs</a> *pThis)</td></tr>
<tr class="memdesc:ga3e6f1b5169818bd92f98a01a964682f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a Correlated Data object, cleaning up it's memory.  <a href="#ga3e6f1b5169818bd92f98a01a964682f2">More...</a><br/></td></tr>
<tr class="separator:ga3e6f1b5169818bd92f98a01a964682f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8991ab833d522b3ca84043ceeeeba7bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga8991ab833d522b3ca84043ceeeeba7bd">DasDs_shape</a> (const <a class="el" href="structDasDs.html">DasDs</a> *pThis, ptrdiff_t *pShape)</td></tr>
<tr class="memdesc:ga8991ab833d522b3ca84043ceeeeba7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current valid ranges for whole data set iteration.  <a href="#ga8991ab833d522b3ca84043ceeeeba7bd">More...</a><br/></td></tr>
<tr class="separator:ga8991ab833d522b3ca84043ceeeeba7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga356abb564384f43a6753d935b5c1bf76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga356abb564384f43a6753d935b5c1bf76">dasds_iter_init</a> (<a class="el" href="structdasds__iterator.html">dasds_iterator</a> *pIter, const <a class="el" href="structDasDs.html">DasDs</a> *pDs)</td></tr>
<tr class="memdesc:ga356abb564384f43a6753d935b5c1bf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a const dataset iterator.  <a href="#ga356abb564384f43a6753d935b5c1bf76">More...</a><br/></td></tr>
<tr class="separator:ga356abb564384f43a6753d935b5c1bf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae338a879f29e64a98d6f7b1f10a99d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gaae338a879f29e64a98d6f7b1f10a99d5">dasds_iter_next</a> (<a class="el" href="structdasds__iterator.html">dasds_iterator</a> *pIter)</td></tr>
<tr class="memdesc:gaae338a879f29e64a98d6f7b1f10a99d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the iterator's index by one position, rolling as needed at data boundaries.  <a href="#gaae338a879f29e64a98d6f7b1f10a99d5">More...</a><br/></td></tr>
<tr class="separator:gaae338a879f29e64a98d6f7b1f10a99d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga605627db68a664e369f6a5f3724d5240"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga605627db68a664e369f6a5f3724d5240">DasDs_addAry</a> (<a class="el" href="structDasDs.html">DasDs</a> *pThis, <a class="el" href="structDasAry.html">DasAry</a> *pAry)</td></tr>
<tr class="memdesc:ga605627db68a664e369f6a5f3724d5240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an array to the dataset, stealing it's reference.  <a href="#ga605627db68a664e369f6a5f3724d5240">More...</a><br/></td></tr>
<tr class="separator:ga605627db68a664e369f6a5f3724d5240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6fd61556b8a2cf84fc2775c8d1d81d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasDim.html">DasDim</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gaa6fd61556b8a2cf84fc2775c8d1d81d8">DasDs_makeDim</a> (<a class="el" href="structDasDs.html">DasDs</a> *pThis, enum dim_type dType, const char *sId)</td></tr>
<tr class="memdesc:gaa6fd61556b8a2cf84fc2775c8d1d81d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new dimension within this dataset.  <a href="#gaa6fd61556b8a2cf84fc2775c8d1d81d8">More...</a><br/></td></tr>
<tr class="separator:gaa6fd61556b8a2cf84fc2775c8d1d81d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0fed163873d1769cd7fdc63486c28ff"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gab0fed163873d1769cd7fdc63486c28ff">DasDs_group</a> (const <a class="el" href="structDasDs.html">DasDs</a> *pThis)</td></tr>
<tr class="memdesc:gab0fed163873d1769cd7fdc63486c28ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data set group id.  <a href="#gab0fed163873d1769cd7fdc63486c28ff">More...</a><br/></td></tr>
<tr class="separator:gab0fed163873d1769cd7fdc63486c28ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49f795cb620ea088b56dabd3d66f7a61"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga49f795cb620ea088b56dabd3d66f7a61">DasDs_numDims</a> (const <a class="el" href="structDasDs.html">DasDs</a> *pThis, enum dim_type vt)</td></tr>
<tr class="memdesc:ga49f795cb620ea088b56dabd3d66f7a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of physical dimensions in this dataset.  <a href="#ga49f795cb620ea088b56dabd3d66f7a61">More...</a><br/></td></tr>
<tr class="separator:ga49f795cb620ea088b56dabd3d66f7a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3b7c572e0d590e6403b6407bccfad9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structDasDim.html">DasDim</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga5c3b7c572e0d590e6403b6407bccfad9">DasDs_getDim</a> (const <a class="el" href="structDasDs.html">DasDs</a> *pThis, size_t idx, enum dim_type vt)</td></tr>
<tr class="memdesc:ga5c3b7c572e0d590e6403b6407bccfad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a dimension by index.  <a href="#ga5c3b7c572e0d590e6403b6407bccfad9">More...</a><br/></td></tr>
<tr class="separator:ga5c3b7c572e0d590e6403b6407bccfad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b1e092b36553b25fc13c6d5dd78654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasDim.html">DasDim</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gab5b1e092b36553b25fc13c6d5dd78654">DasDs_getDimById</a> (<a class="el" href="structDasDs.html">DasDs</a> *pThis, const char *sId)</td></tr>
<tr class="memdesc:gab5b1e092b36553b25fc13c6d5dd78654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a dimension by string id.  <a href="#gab5b1e092b36553b25fc13c6d5dd78654">More...</a><br/></td></tr>
<tr class="separator:gab5b1e092b36553b25fc13c6d5dd78654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae65f2a83a34ab4db36c4503437946fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasDim.html">DasDim</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gae65f2a83a34ab4db36c4503437946fd4">new_DasDim</a> (const char *sId, enum dim_type dtype, int nRank)</td></tr>
<tr class="memdesc:gae65f2a83a34ab4db36c4503437946fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dimension (not as impressive as it sounds)  <a href="#gae65f2a83a34ab4db36c4503437946fd4">More...</a><br/></td></tr>
<tr class="separator:gae65f2a83a34ab4db36c4503437946fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafab113e6f47d57b7eacd134a4dc63e15"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gafab113e6f47d57b7eacd134a4dc63e15">DasDim_id</a> (const <a class="el" href="structDasDim.html">DasDim</a> *pThis)</td></tr>
<tr class="memdesc:gafab113e6f47d57b7eacd134a4dc63e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension's id.  <a href="#gafab113e6f47d57b7eacd134a4dc63e15">More...</a><br/></td></tr>
<tr class="separator:gafab113e6f47d57b7eacd134a4dc63e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f43318cd9c639a419d9eab33739736"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga62f43318cd9c639a419d9eab33739736">DasDim_toStr</a> (const <a class="el" href="structDasDim.html">DasDim</a> *pThis, char *sBuf, int nLen)</td></tr>
<tr class="memdesc:ga62f43318cd9c639a419d9eab33739736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an information string describing a dimension.  <a href="#ga62f43318cd9c639a419d9eab33739736">More...</a><br/></td></tr>
<tr class="separator:ga62f43318cd9c639a419d9eab33739736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d644100226032dac7fe70eb7c8181b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gaa5d644100226032dac7fe70eb7c8181b">DasDim_copyInProps</a> (<a class="el" href="structDasDim.html">DasDim</a> *pThis, char cAxis, const <a class="el" href="structDasDesc.html">DasDesc</a> *pOther)</td></tr>
<tr class="memdesc:gaa5d644100226032dac7fe70eb7c8181b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy in dataset properties from some other descriptor.  <a href="#gaa5d644100226032dac7fe70eb7c8181b">More...</a><br/></td></tr>
<tr class="separator:gaa5d644100226032dac7fe70eb7c8181b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbdb2e515afa53e55f1ca6b398ef119c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gacbdb2e515afa53e55f1ca6b398ef119c">DasDim_addVar</a> (<a class="el" href="structDasDim.html">DasDim</a> *pThis, const char *sRole, <a class="el" href="structDasVar.html">DasVar</a> *pVar)</td></tr>
<tr class="memdesc:gacbdb2e515afa53e55f1ca6b398ef119c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a variable to a dimension.  <a href="#gacbdb2e515afa53e55f1ca6b398ef119c">More...</a><br/></td></tr>
<tr class="separator:gacbdb2e515afa53e55f1ca6b398ef119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e6904bd78bcaeaa10f132c6ca6b2c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structDasVar.html">DasVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gaf8e6904bd78bcaeaa10f132c6ca6b2c8">DasDim_getVar</a> (const <a class="el" href="structDasDim.html">DasDim</a> *pThis, const char *sRole)</td></tr>
<tr class="memdesc:gaf8e6904bd78bcaeaa10f132c6ca6b2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a variable providing values for a particular role in the dimension.  <a href="#gaf8e6904bd78bcaeaa10f132c6ca6b2c8">More...</a><br/></td></tr>
<tr class="separator:gaf8e6904bd78bcaeaa10f132c6ca6b2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fa5c997f0304022c6f5667ffae3ccf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structDasVar.html">DasVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga30fa5c997f0304022c6f5667ffae3ccf">DasDim_getPointVar</a> (const <a class="el" href="structDasDim.html">DasDim</a> *pThis)</td></tr>
<tr class="memdesc:ga30fa5c997f0304022c6f5667ffae3ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a variable poviding single point values in a dimension.  <a href="#ga30fa5c997f0304022c6f5667ffae3ccf">More...</a><br/></td></tr>
<tr class="separator:ga30fa5c997f0304022c6f5667ffae3ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5abe563a70a6672eaf5970ebf5db89a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasVar.html">DasVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gae5abe563a70a6672eaf5970ebf5db89a">DasDim_popVar</a> (<a class="el" href="structDasDim.html">DasDim</a> *pThis, const char *role)</td></tr>
<tr class="memdesc:gae5abe563a70a6672eaf5970ebf5db89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a variable by role from a dimensions.  <a href="#gae5abe563a70a6672eaf5970ebf5db89a">More...</a><br/></td></tr>
<tr class="separator:gae5abe563a70a6672eaf5970ebf5db89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e0b450a1e02c548c27a35a1cde17e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga47e0b450a1e02c548c27a35a1cde17e2">del_DasDim</a> (<a class="el" href="structDasDim.html">DasDim</a> *pThis)</td></tr>
<tr class="memdesc:ga47e0b450a1e02c548c27a35a1cde17e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a dimension and drop the reference count on all contained variables.  <a href="#ga47e0b450a1e02c548c27a35a1cde17e2">More...</a><br/></td></tr>
<tr class="separator:ga47e0b450a1e02c548c27a35a1cde17e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f09878a837d1a0c1cf4b1fd0f308827"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga4f09878a837d1a0c1cf4b1fd0f308827">DasDim_shape</a> (const <a class="el" href="structDasDim.html">DasDim</a> *pThis, ptrdiff_t *pShape)</td></tr>
<tr class="memdesc:ga4f09878a837d1a0c1cf4b1fd0f308827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum extent of this dimension in index space.  <a href="#ga4f09878a837d1a0c1cf4b1fd0f308827">More...</a><br/></td></tr>
<tr class="separator:ga4f09878a837d1a0c1cf4b1fd0f308827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff70b178720ffb9f9529a1f4f3909cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasVar.html">DasVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga1ff70b178720ffb9f9529a1f4f3909cc">new_DasVarUnary</a> (const char *sOp, const <a class="el" href="structDasVar.html">DasVar</a> *pVar)</td></tr>
<tr class="memdesc:ga1ff70b178720ffb9f9529a1f4f3909cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new variable from unary operation on an existing variable.  <a href="#ga1ff70b178720ffb9f9529a1f4f3909cc">More...</a><br/></td></tr>
<tr class="separator:ga1ff70b178720ffb9f9529a1f4f3909cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga296f0f0d5adfab6e0ea165fedd8167aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasVar.html">DasVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga296f0f0d5adfab6e0ea165fedd8167aa">new_DasVarBinary</a> (<a class="el" href="structDasVar.html">DasVar</a> *pLeft, const char *sOp, <a class="el" href="structDasVar.html">DasVar</a> *pRight)</td></tr>
<tr class="memdesc:ga296f0f0d5adfab6e0ea165fedd8167aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new variable from a binary operation on two other variables.  <a href="#ga296f0f0d5adfab6e0ea165fedd8167aa">More...</a><br/></td></tr>
<tr class="separator:ga296f0f0d5adfab6e0ea165fedd8167aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45bc9600732950fd7ba4da5a9dfeb53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasVar.html">DasVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#gaa45bc9600732950fd7ba4da5a9dfeb53">new_DasConstant</a> (<a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> vt, size_t sz, const void *val, <a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a> units)</td></tr>
<tr class="memdesc:gaa45bc9600732950fd7ba4da5a9dfeb53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a constant value on the heap.  <a href="#gaa45bc9600732950fd7ba4da5a9dfeb53">More...</a><br/></td></tr>
<tr class="separator:gaa45bc9600732950fd7ba4da5a9dfeb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1fd82011eb05d1a89605eb8eea1314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasVar.html">DasVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga5d1fd82011eb05d1a89605eb8eea1314">new_DasVarSeq</a> (const char *sId, <a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> vt, size_t vSz, const void *pMin, const void *pInterval, int8_t *pMap, <a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a> units)</td></tr>
<tr class="memdesc:ga5d1fd82011eb05d1a89605eb8eea1314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sequence variable.  <a href="#ga5d1fd82011eb05d1a89605eb8eea1314">More...</a><br/></td></tr>
<tr class="separator:ga5d1fd82011eb05d1a89605eb8eea1314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982d2249ebb193fd5fdf8df61c91ab61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasVar.html">DasVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga982d2249ebb193fd5fdf8df61c91ab61">new_DasVarArray</a> (<a class="el" href="structDasAry.html">DasAry</a> *pAry, int iInternal, int8_t *pMap)</td></tr>
<tr class="memdesc:ga982d2249ebb193fd5fdf8df61c91ab61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function backed by an Array.  <a href="#ga982d2249ebb193fd5fdf8df61c91ab61">More...</a><br/></td></tr>
<tr class="separator:ga982d2249ebb193fd5fdf8df61c91ab61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dfd7f7c30810e8306a656d99bcfc9fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga2dfd7f7c30810e8306a656d99bcfc9fb">DasVarAry_getArray</a> (<a class="el" href="structDasVar.html">DasVar</a> *pThis)</td></tr>
<tr class="memdesc:ga2dfd7f7c30810e8306a656d99bcfc9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the backing array if present.  <a href="#ga2dfd7f7c30810e8306a656d99bcfc9fb">More...</a><br/></td></tr>
<tr class="separator:ga2dfd7f7c30810e8306a656d99bcfc9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82b382b377d5f4dfd3148f89fcafddd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga82b382b377d5f4dfd3148f89fcafddd2">DasVar_orthoginal</a> (const <a class="el" href="structDasVar.html">DasVar</a> *pThis, const <a class="el" href="structDasVar.html">DasVar</a> *pOther)</td></tr>
<tr class="memdesc:ga82b382b377d5f4dfd3148f89fcafddd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting data from a variable.  <a href="#ga82b382b377d5f4dfd3148f89fcafddd2">More...</a><br/></td></tr>
<tr class="separator:ga82b382b377d5f4dfd3148f89fcafddd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a54a5eaecf157cef1610cfaf5efe7f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga6a54a5eaecf157cef1610cfaf5efe7f1">DasVar_shape</a> (const <a class="el" href="structDasVar.html">DasVar</a> *pThis, ptrdiff_t *pShape)</td></tr>
<tr class="memdesc:ga6a54a5eaecf157cef1610cfaf5efe7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current shape of this variable.  <a href="#ga6a54a5eaecf157cef1610cfaf5efe7f1">More...</a><br/></td></tr>
<tr class="separator:ga6a54a5eaecf157cef1610cfaf5efe7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e2996f3508f8d42fb4534f69d55954b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga8e2996f3508f8d42fb4534f69d55954b">DasVar_getDatum</a> (const <a class="el" href="structDasVar.html">DasVar</a> *pThis, ptrdiff_t *pIdx, <a class="el" href="structdas__datum.html">das_datum</a> *pDatum)</td></tr>
<tr class="memdesc:ga8e2996f3508f8d42fb4534f69d55954b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a value given an index.  <a href="#ga8e2996f3508f8d42fb4534f69d55954b">More...</a><br/></td></tr>
<tr class="separator:ga8e2996f3508f8d42fb4534f69d55954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e72e7fdd5446a7595e8454ecd04f540"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga2e72e7fdd5446a7595e8454ecd04f540">DasVar_isComposite</a> (const <a class="el" href="structDasVar.html">DasVar</a> *pVar)</td></tr>
<tr class="memdesc:ga2e72e7fdd5446a7595e8454ecd04f540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a simple variable or more than one variable combinded via operators?  <a href="#ga2e72e7fdd5446a7595e8454ecd04f540">More...</a><br/></td></tr>
<tr class="separator:ga2e72e7fdd5446a7595e8454ecd04f540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01aac56dce4993ba2c9c28b31f6afdb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datasets.html#ga01aac56dce4993ba2c9c28b31f6afdb3">dec_DasVar</a> (<a class="el" href="structDasVar.html">DasVar</a> *pThis)</td></tr>
<tr class="memdesc:ga01aac56dce4993ba2c9c28b31f6afdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the reference count on a variable.  <a href="#ga01aac56dce4993ba2c9c28b31f6afdb3">More...</a><br/></td></tr>
<tr class="separator:ga01aac56dce4993ba2c9c28b31f6afdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab1ad242b3b37d4b5ef491a5d9df614e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t DasDs_lengthIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDs.html">DasDs</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current max value index value + 1 for any partial index. </p>
<p>This is a more general version of DasDim_shape that works for both cubic arrays and with ragged dimensions, or sequence values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to a <a class="el" href="structDasDim.html" title="Das2 Physical Dimensions. ">DasDim</a> structure </td></tr>
    <tr><td class="paramname">nIdx</td><td>The number of location indices which may be less than the number needed to specify an exact value. </td></tr>
    <tr><td class="paramname">pLoc</td><td>A list of values for the previous indexes, must be a value greater than or equal to 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of sub-elements at this index location or D2IDX_UNUSED if this variable doesn't depend on a given location, or D2IDx_FUNC if this variable returns computed results for this location</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDasAry.html#aeba8aae921ce4e1087dfb2d946174dcb" title="Return the current max value + 1 for any index. ">DasAry_lengthIn</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga88fb0e6591ff9d290529ea35ef9e9e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DasDs_copyInProps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDs.html">DasDs</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy in dataset properties from some other descriptor. </p>
<p>This is a helper for das 2.2 streams.</p>
<p>Any properties that don't start with a specific dimension identifier i.e. 'x','y','z','w' are copied into this dataset's properties dictionary. Only properties not present in the internal dictionary are copied in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>this dataset object </td></tr>
    <tr><td class="paramname">pOther</td><td>The descriptor containing properites to copy in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of properties copied in </dd></dl>

</div>
</div>
<a class="anchor" id="gaf76625550faffb01559e9e6e05cfbdd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* DasDs_toStr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDs.html">DasDs</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a string reprenestation of this dataset. </p>
<p>Note: Datasets can be complicated items provide a good sized buffer (~1024 bytes), when calling this function as it triggers subcalls for all the compontent toStr as well </p>

</div>
</div>
<a class="anchor" id="gadcd7d415f4404c3d2c1388eaeb31944e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t DasDim_lengthIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDim.html">DasDim</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current max value index value + 1 for any partial index. </p>
<p>This is a more general version of DasDim_shape that works for both cubic arrays and with ragged dimensions, or sequence values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to a <a class="el" href="structDasDim.html" title="Das2 Physical Dimensions. ">DasDim</a> strutcture </td></tr>
    <tr><td class="paramname">nIdx</td><td>The number of location indices which may be less than the number needed to specify an exact value. </td></tr>
    <tr><td class="paramname">pLoc</td><td>A list of values for the previous indexes, must be a value greater than or equal to 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of sub-elements at this index location or D2IDX_UNUSED if this variable doesn't depend on a given location, or D2IDx_FUNC if this variable returns computed results for this location</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDasAry.html#aeba8aae921ce4e1087dfb2d946174dcb" title="Return the current max value + 1 for any index. ">DasAry_lengthIn</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae7147e064f00b1aeaf8c9f163d492dc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int das_op_unary </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string into a unary operator token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sOp</td><td>a string such as "-", "sqrt", etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an operator token id or 0 if the string did not corespond to a known unary operator </dd></dl>

</div>
</div>
<a class="anchor" id="ga57ddf7d68e0adc463548fbec76affa25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int das_op_binary </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string into a binary operator token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sOp</td><td>a string such as "+", "-", "*", "/", "**", "^" etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an operator token id or 0 if the string did not corespond to a known unary operator </dd></dl>

</div>
</div>
<a class="anchor" id="ga279ce76e2f8deaf2d50fb47c864b9160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* das_op_toStr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a string representation of an operator token and an indication of where the operator normally appears. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nOp</td><td>The operator token value</td></tr>
    <tr><td class="paramname">pos</td><td>a pointer to an integer to receive one of the values D2OP_BEFORE, D2OP_BETWEEN or D2OP_AFTER. If pos is NULL the operator position is not set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a character representation of the operator or NULL if the token nOp is unknown. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4ff1c2981bb42fb83fb55c6a8c87b57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t DasVar_lengthIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current max value index value + 1 for any partial index. </p>
<p>This is a more general version of DasVar_shape that works for both cubic arrays and with ragged dimensions, or sequence values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to a <a class="el" href="structDasVar.html" title="Das2 fexible variables. ">DasVar</a> structure </td></tr>
    <tr><td class="paramname">nIdx</td><td>The number of location indices which may be less than the number needed to specify an exact value. </td></tr>
    <tr><td class="paramname">pLoc</td><td>A list of values for the previous indexes, must be a value greater than or equal to 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of sub-elements at this index location or D2IDX_UNUSED if this variable doesn't depend on a given location, or D2IDx_FUNC if this variable returns computed results for this location</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDasAry.html#aeba8aae921ce4e1087dfb2d946174dcb" title="Return the current max value + 1 for any index. ">DasAry_lengthIn</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga768190231541563b83fa766fd57210fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* DasVar_toStr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a string representation of this variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>a pointer to variable in question</td></tr>
    <tr><td class="paramname">sBuf</td><td>a buffer to hold the output, 128 bytes should be more than enough unless describing a deeply nested set of binary operation variables are preset.</td></tr>
    <tr><td class="paramname">nLen</td><td>the length of the string buffer. This function will not write more than nLen - 1 bytes to the buffer and will insure NULL termination </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad1a467a4ea3c7bd859b6b8acccdbc579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasDs.html">DasDs</a> * new_DasDs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sGroupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new dataset object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sId</td><td>An identifier for this dataset should be unique within a group but this requirement is not yet enforced.</td></tr>
    <tr><td class="paramname">sGroupId</td><td>An identifier for the group to which the dataset belongs. Datasets within a group can be plotted in the same physical dimensions, though the index shape need not be the same in any respect.</td></tr>
  </table>
  </dd>
</dl>
<p>Said another way, datasets in the same group must have the same number of coordinate and data dimensions and the units of corresponding variables in the datasets should be identical, or at least inter-convertible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nRank</td><td>The overall iteration rank for the dataset, i.e. the number of indicies needed to retrive values from this dataset's variables. ALL variables in a dateset accept the same number of indices in the same relative positions when reading values.</td></tr>
  </table>
  </dd>
</dl>
<p>Unlike ISTP CDF's, rank is an iteration property and has no defined relationship to the number of physical dimensions of the dataset. Thus two datasets may have different ranks but be part of the same group.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga3e6f1b5169818bd92f98a01a964682f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void del_DasDs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDs.html">DasDs</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a Correlated Data object, cleaning up it's memory. </p>
<p>If the underlying arrays and property values are needed else where call </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The correlated data sets object to delete, provided pointer should be set to NULL after this operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8991ab833d522b3ca84043ceeeeba7bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DasDs_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDs.html">DasDs</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return current valid ranges for whole data set iteration. </p>
<p>To plot all values in a dataset iterate over the entire range provided for each function. The returned shape is the maximum value + 1 of each index of the given dataset. The shape can change as data are added to the dataset.</p>
<p>Data variables that include point spread functions and variables that provide vectors require an inner iteration that is not part of the returned shape.</p>
<p>Note that for a properly defined dataset all indices below the rank of the dataset will be used.</p>
<div class="fragment"><div class="line">* <span class="comment">// Setup the shape array to contain all D2IDX_UNUSED values first</span></div>
<div class="line">* ptrdiff_t aBulkShape[D2IDX_MAX] = D2IDX_EMPTY;</div>
<div class="line">* </div>
<div class="line">* <span class="comment">// Now get the shape</span></div>
<div class="line">* <span class="keywordtype">int</span> nRank = <a class="code" href="group__datasets.html#ga8991ab833d522b3ca84043ceeeeba7bd">DasDs_shape</a>(pDs, aBulkShape);</div>
<div class="line">* </div>
<div class="line">* </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pThis</td><td>A pointer to a dataset object</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pShape</td><td>pointer to an array to receive the current bulk iteration shape required to get all the values from all variables in the dataset.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>An integer from 0 to LONG_MAX indicating the valid range of values for this index.</li>
<li>The constant D2IDX_RAGGED indicating that the range of values for this index depend on upper indicies.</li>
<li>The constant D2IDX_UNUSED to indicate that a index is un-used by this dataset.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The iteration rank sufficient to read all coordinate and data values. </dd></dl>

</div>
</div>
<a class="anchor" id="ga356abb564384f43a6753d935b5c1bf76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dasds_iter_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdasds__iterator.html">dasds_iterator</a> *&#160;</td>
          <td class="paramname"><em>pIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDasDs.html">DasDs</a> *&#160;</td>
          <td class="paramname"><em>pDs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a const dataset iterator. </p>
<p>The initialized iterator is safe to use for datasets that are growing as it will not exceed the valid index range of the dataset at the time this function was called. However, if the dataset shrinks during iteration das_iter_next() could overstep the array bounds.</p>
<p>For usage see the example in ::das_iterator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pIter</td><td>A pointer to an iterator, will be initialize to index 0</td></tr>
    <tr><td class="paramname">pDs</td><td>A pointer to a dataset. If the dataset changes while the iterator is in use invalid memory access could occur </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaae338a879f29e64a98d6f7b1f10a99d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dasds_iter_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdasds__iterator.html">dasds_iterator</a> *&#160;</td>
          <td class="paramname"><em>pIter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the iterator's index by one position, rolling as needed at data boundaries. </p>
<p>For efficiency this function does not re-check array bounds on each call a slower but safer version of this function could be created if needed.</p>
<p>For usage see the example in ::das_iterator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pIter</td><td>A pointer to an iterator. The index member of the iterator will be incremented.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the new index is within range, false if the index could not be incremented without producing an invalid location. </dd></dl>

</div>
</div>
<a class="anchor" id="ga605627db68a664e369f6a5f3724d5240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DasDs_addAry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDs.html">DasDs</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pAry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an array to the dataset, stealing it's reference. </p>
<p>Arrays are raw backing storage for the dataset. They contain elements but do not provide a meaning for those elements. Variables are a semantic layer on top of the raw arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>a Dataset structure pointer</td></tr>
    <tr><td class="paramname">pAry</td><td>The array to add. Note: This function "steals" a reference to the array. Meaning it does not increment the refenece count of the array when adding it to the function, but it <b>does</b> decrement the refenece when the dataset is deleted! So if you want the calling code to still have access to the array after the dataset it's attached too is removed you'll have to call <a class="el" href="structDasAry.html#a0229ceac1cca3435b61a8d5bf32425e1" title="Increment the count of objects using this Das Array. ">inc_DasAry()</a> on your own.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Almost always returns true. The array list in the dataset requires a small malloc (array memory itself is <em>NOT</em> copied.) This function only returns false in the rare instance that a few dozen bytes can not be allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6fd61556b8a2cf84fc2775c8d1d81d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasDim.html">DasDim</a> * DasDs_makeDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDs.html">DasDs</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum dim_type&#160;</td>
          <td class="paramname"><em>dType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a new dimension within this dataset. </p>
<p>Adding a dimension to a dataset will change cause the parent descriptor for the variable to be set to this dataset. The dataset takes ownership of the variable and will delete it when the dataset is deleted</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to a dataset structure</td></tr>
    <tr><td class="paramname">dType</td><td>The type of dimension. If this is a coordinate dimension all data dimensions that vary in any of the same indices as this dimension will be set to depend on these coordinates.</td></tr>
    <tr><td class="paramname">sId</td><td>A name for this dimension. Standard names such as 'time', 'frequence' 'range' 'altitude' etc. should be used if possible. No standard list of dimension names are provided by this library, it is left up to the application programmers to handle this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab0fed163873d1769cd7fdc63486c28ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * DasDs_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDs.html">DasDs</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data set group id. </p>
<p>Datasets with the same group ID are representable in the same coordinate and data types (for example time, frequency, and power), but have different locations in the coordinate space. Another way of saying this is all datasets with have the same physical units for thier coordinates and data but not the same coordinate values.</p>
<p>Since a dataset is defined in this library to include all items in as single index space more than one dataset may encountered in a stream. All datasets with the same groupID should be plottable on the same set of axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The dataset sturcture </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string pointer than is never null </dd></dl>

</div>
</div>
<a class="anchor" id="ga49f795cb620ea088b56dabd3d66f7a61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t DasDs_numDims </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDs.html">DasDs</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum dim_type&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of physical dimensions in this dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The dataset object </td></tr>
    <tr><td class="paramname">vt</td><td>The variable type, either COOR or DATA </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data functions provided for a dataset. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c3b7c572e0d590e6403b6407bccfad9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structDasDim.html">DasDim</a> * DasDs_getDim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDs.html">DasDs</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum dim_type&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a dimension by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>a pointer to a dataset structure </td></tr>
    <tr><td class="paramname">idx</td><td>the index of the variable in question </td></tr>
    <tr><td class="paramname">vt</td><td>the variable type, either COORD or DATA </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Variable pointer or NULL if idx is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="gab5b1e092b36553b25fc13c6d5dd78654"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasDim.html">DasDim</a> * DasDs_getDimById </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDs.html">DasDs</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a dimension by string id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>a pointer to a dataset structure </td></tr>
    <tr><td class="paramname">sId</td><td>The name of the dimension to retrieve, for example 'time' or 'frequency' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dimesion pointer or NULL if sId does not match any dimesion name </dd></dl>

</div>
</div>
<a class="anchor" id="gae65f2a83a34ab4db36c4503437946fd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasDim.html">DasDim</a> * new_DasDim </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum dim_type&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new dimension (not as impressive as it sounds) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sId</td><td>The id of the dimension, which should be a common name such as time, energy, frequency, latitude, longitude, solar_zenith_angle, electric_spectral_density, netural_flux_density, etc. It's much more important for coordinate dimensions to have common names than data dimensions.</td></tr>
    <tr><td class="paramname">dtype</td><td>One of DASDIM_COORD, DASDIM_DATA</td></tr>
    <tr><td class="paramname">nRank</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gafab113e6f47d57b7eacd134a4dc63e15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * DasDim_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDim.html">DasDim</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimension's id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>a pointer to a das dimension structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The id of the dimension, which should be a common name such as time, energy, frequency, electric_spectral_density, netural_flux_density, etc. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62f43318cd9c639a419d9eab33739736"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * DasDim_toStr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDim.html">DasDim</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an information string describing a dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to a dimension structure </td></tr>
    <tr><td class="paramname">sBuf</td><td>A buffer to hold the description </td></tr>
    <tr><td class="paramname">nLen</td><td>Warning, these can be long so provide around 256 bytes or more of storage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next write location within the buffer sBuf that can be used for appending more text. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5d644100226032dac7fe70eb7c8181b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DasDim_copyInProps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDim.html">DasDim</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>cAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy in dataset properties from some other descriptor. </p>
<p>This is a helper for das 2.2 streams as these use certian name patterns to indicate which dimension a property is for</p>
<p>Any properties that start with a specific dimension identifier i.e. 'x','y','z','w' are copied into this dataset's properties dictionary. Only properties not present in the internal dictionary are copied in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>this dimension object </td></tr>
    <tr><td class="paramname">cAxis</td><td>the connonical axis to copy in. </td></tr>
    <tr><td class="paramname">pOther</td><td>The descriptor containing properites to copy in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of properties copied in </dd></dl>

</div>
</div>
<a class="anchor" id="gacbdb2e515afa53e55f1ca6b398ef119c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DasDim_addVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDim.html">DasDim</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sRole</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pVar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a variable to a dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>the dimesion in question </td></tr>
    <tr><td class="paramname">pVar</td><td>the variable to add </td></tr>
    <tr><td class="paramname">role</td><td>The type of information this variable supplies for the dimension. Any string may be used, standard values are provided in the defines: DASVAR_CENTER, DASVAR_MIN, DASVAR_MAX, DASVAR_WIDTH, DASVAR_REF, DASVAR_OFFSET, DASVAR_MEAN, DASVAR_MEDIAN, DASVAR_MODE, DASVAR_MAX_ERR, DASVAR_MIN_ERR, DASVAR_UNCERT, DASVAR_STD_DEV, DASVAR_SPREAD, and DASVAR_WEIGHT. Any string under 32 characters is acceptable, using a single case is prefered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the variable could be added, or false otherwise. Trying to add a second variable for the same role will result in a return value of false. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf8e6904bd78bcaeaa10f132c6ca6b2c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structDasVar.html">DasVar</a> * DasDim_getVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDim.html">DasDim</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sRole</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a variable providing values for a particular role in the dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to a dimension</td></tr>
    <tr><td class="paramname">sRole</td><td>A string defining the role, Any string may be used, standard values are provided in the defines: DASVAR_CENTER, DASVAR_MIN, DASVAR_MAX, DASVAR_WIDTH, DASVAR_REF, DASVAR_OFFSET, DASVAR_MEAN, DASVAR_MEDIAN, DASVAR_MODE, DASVAR_MAX_ERR, DASVAR_MIN_ERR, DASVAR_UNCERT, DASVAR_STD_DEV, DASVAR_SPREAD, and DASVAR_WEIGHT.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="structDasVar.html" title="Das2 fexible variables. ">DasVar</a> or NULL if no variable exists within this dimension for the given role. </dd></dl>

</div>
</div>
<a class="anchor" id="ga30fa5c997f0304022c6f5667ffae3ccf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structDasVar.html">DasVar</a> * DasDim_getPointVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDim.html">DasDim</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a variable poviding single point values in a dimension. </p>
<p>The most common variable role, DASVAR_CENTER, is typically present in a dimension but not always. Sometimes other roles take this variable's place, such as the mean, median or mode or an average of the minimum and maximum values. Use this function to autoselct a variable to use as the center point when plotting data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to a dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a variable that can be used to provide single points in this dimension, or NULL in the rare instance that nothing in this dimesion can be used for single point values. A return of false from this call probably means you have an invalid or highly customized dataset. </dd></dl>

</div>
</div>
<a class="anchor" id="gae5abe563a70a6672eaf5970ebf5db89a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasVar.html">DasVar</a> * DasDim_popVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDim.html">DasDim</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a variable by role from a dimensions. </p>
<p>The caller is considered to own the variable and must delete it if no longer in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The dimension in question</td></tr>
    <tr><td class="paramname">role</td><td>A role string. Can be anything less that 32 characters but library uses are recommened to choose from the predefined strings: D2VP_CENTER, D2VP_MIN, D2VP_MAX, D2VP_WIDTH, D2VP_MEAN, D2VP_MEDIAN, D2VP_MODE, D2VP_REF, D2VP_OFFSET, D2VP_MAXERR, D2VP_MINERR, D2VP_UNCERT, D2VP_STD_DEV</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the variable occuping the given role, or NULL if no variable occupied the specified role </dd></dl>

</div>
</div>
<a class="anchor" id="ga47e0b450a1e02c548c27a35a1cde17e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void del_DasDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDim.html">DasDim</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a dimension and drop the reference count on all contained variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to a dimension structure. This pointer should be set to NULL after calling this function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4f09878a837d1a0c1cf4b1fd0f308827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DasDim_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDim.html">DasDim</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum extent of this dimension in index space. </p>
<p>This function can be used to determine if there is a set of indices that when changed, only affect the values of the variables in one dimension without affecting the other. If such an index set exists then the dimensions are orthogonal in index space.</p>
<div class="fragment"><div class="line">* <span class="comment">// Given two dimension structure pointer, pLat and pLong</span></div>
<div class="line">* <span class="keywordtype">int</span> lat_shape[D2ARY_MAXIDX];</div>
<div class="line">* <span class="keywordtype">int</span> long_shape[D2ARY_MAXIDX];</div>
<div class="line">* </div>
<div class="line">* <a class="code" href="group__datasets.html#ga4f09878a837d1a0c1cf4b1fd0f308827">DasDim_shape</a>(pLat, lat_shape);</div>
<div class="line">* <a class="code" href="group__datasets.html#ga4f09878a837d1a0c1cf4b1fd0f308827">DasDim_shape</a>(pLong, long_shape);</div>
<div class="line">* </div>
<div class="line">* <span class="keywordflow">if</span>(Shape_IsOrthoginal(lat_shape, long_shape)){</div>
<div class="line">*     <span class="comment">// Yes, we can slice in latitude and longitude simply by changing the</span></div>
<div class="line">*     <span class="comment">// indices lat_shape but not long_shape and vice versa</span></div>
<div class="line">* }</div>
<div class="line">* <span class="keywordflow">else</span>{</div>
<div class="line">*     <span class="comment">// No, we can&#39;t simply slice in index space to hold latitude or </span></div>
<div class="line">*    <span class="comment">// longitude constant.  Will need to define an index of a latitude or</span></div>
<div class="line">*     <span class="comment">// longitude range.  I.e. will need to make a thin slab in</span></div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --><p>This is a convenience wrapper around Variable_shape that takes the maximum extent in all contained variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>the Coordinate Dimension or Data Dimension in question</td></tr>
    <tr><td class="paramname">pShape</td><td>a pointer to an array up to D2ARY_MAXDIM in size to receive the shape values. A -1 in any position means that the index in question does not affect any of variables within this dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rank of the variable</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Variable_shape() </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ff70b178720ffb9f9529a1f4f3909cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasVar.html">DasVar</a> * new_DasVarUnary </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pVar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new variable from unary operation on an existing variable. </p>
<p>Create a virtual variable from Operation(SubVar) as needed on an element by element basis, for example "Var1**-2", or "- Var1". For efficency, simple powers are combined into the operator.</p>
<p>The new variable dose not allocate any storage, Getting elements from this variable will result in a sub-variable lookup and a calculation based on the given operator.</p>
<p>If a variable is to be iterated over multiple times the function <a class="el" href="group__datasets.html#gabb45a6ca58ed1754dcfabe85f5816bb6" title="Evaluate all sub-variable expressions and a single array variable. ">new_DasVarEval()</a> can be used to run this calculation and any sub calculations over all internal arrays and output the result into a new storage array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sOp</td><td>a string of lowercase letters or numbers describing the operation to apply. The following strings are understood: "-", "**2", "**3" "**-2", "**-3", "ln", "log", "sqrt", "curt", "sin", "cos", "tan"</td></tr>
    <tr><td class="paramname">pVar</td><td>The variable to modify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="structDasVar.html" title="Das2 fexible variables. ">DasVar</a> allocated on the heap with it's reference count set to one.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__datasets.html#gabb45a6ca58ed1754dcfabe85f5816bb6" title="Evaluate all sub-variable expressions and a single array variable. ">new_DasVarEval</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga296f0f0d5adfab6e0ea165fedd8167aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasVar.html">DasVar</a> * new_DasVarBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new variable from a binary operation on two other variables. </p>
<p>Create a virtual variable from Var1 Operator Var2, for example Var1 + Var2.</p>
<p>The new variable does not allocate any storage though it does pre-calculate any needed scaling factors. Getting elements from this variable will result in two sub-variable lookups and a calculation based on the given operator.</p>
<p>The two variables must produce the same number of values when given the same set of indices. Most variables do not have an internal index so this is usually satisfied.</p>
<p>The two variables must have units that can be combined using given operator. Typically this means they must have the same units, but epoch units can be combined with pure "length" (i.e. duration) units under the addition and subtraction operators but two epoch units cannot be combined.</p>
<p>The new variable created by this binary combination will the units of the right sub-variable. Output of the left sub-variable will be scaled if needed before being combined on an element by element basis with the right sub-variable.</p>
<p>If a variable is to be iterated over multiple times the function <a class="el" href="group__datasets.html#gabb45a6ca58ed1754dcfabe85f5816bb6" title="Evaluate all sub-variable expressions and a single array variable. ">new_DasVarEval()</a> can be used to run this calculation and any sub calculations over all internal arrays and output the result into a new storage array</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLeft</td><td>the left index variable for the binary operation</td></tr>
    <tr><td class="paramname">sOp</td><td>the operation to preform, The following strings are understood "+","-","/","*","pow"</td></tr>
    <tr><td class="paramname">pRight</td><td>the indexed variable in the binary operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new variable or NULL if an error occurred such as an unknown operator string.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__datasets.html#gabb45a6ca58ed1754dcfabe85f5816bb6" title="Evaluate all sub-variable expressions and a single array variable. ">new_DasVarEval</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa45bc9600732950fd7ba4da5a9dfeb53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasVar.html">DasVar</a> * new_DasConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a>&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a>&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a constant value on the heap. </p>
<p>Constant variables ignore the given index value and always return the supplied constant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vt</td><td>The element type for the constant, must a type with a known width. See new_DasVar_custConst()</td></tr>
    <tr><td class="paramname">sz</td><td>The size of the data value in bytes. This is ignored for types with a known size and can just be set to 0. If using the value type vtUnknown you will need to provide the value size</td></tr>
    <tr><td class="paramname">val</td><td>A pointer to the value which will be copied internally. This is efficient for items less than 32 bytes long, otherwise a malloc is issued.</td></tr>
    <tr><td class="paramname">units</td><td>The singleton unit string for this variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5d1fd82011eb05d1a89605eb8eea1314"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasVar.html">DasVar</a> * new_DasVarSeq </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a>&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>pMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a>&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sequence variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sId</td><td>An identifier for this sequence, follows rules for array ids </td></tr>
    <tr><td class="paramname">vt</td><td>the value type must be one of the values in <a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530" title="Enumeration of types stored in Das Array (DasAry) objects Not that any kind of value may be stored in...">das_val_type</a> </td></tr>
    <tr><td class="paramname">vSz</td><td>the size in bytes for the value type, only used for vtByteSeq types </td></tr>
    <tr><td class="paramname">pMin</td><td>The minimum value for the sequence </td></tr>
    <tr><td class="paramname">pInterval</td><td>The interval between values of the sequence </td></tr>
    <tr><td class="paramname">pMap</td><td>A mapping from <a class="el" href="structDasDs.html" title="Das2 Datasets. ">DasDs</a> indices to this sequence's lone index. The map should only have one value set to D2IDX_FUNC, the rest should be set to D2IDX_UNUSED </td></tr>
    <tr><td class="paramname">units</td><td>The units for values produced by this sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga982d2249ebb193fd5fdf8df61c91ab61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasVar.html">DasVar</a> * new_DasVarArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pAry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iInternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>pMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a function backed by an Array. </p>
<p>This variable will be backed by an array though the array indicies do not have to match the variable indicies. For example an array of frequencies for a time, frequency spectrogram might only have a single index [i], but the variable could access these as index [i][j] where j for the function maps to i for the array and i for the variable is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAry</td><td>The array which contains coordinate values</td></tr>
    <tr><td class="paramname">iInternal</td><td>The number of indicies that are global to the dataset. Alternatively the position in the map that corresponds to the first internal index (if any).</td></tr>
  </table>
  </dd>
</dl>
<p>After mapping everything in pMap upto (but not including) iInternal, any remaining <a class="el" href="structDasAry.html" title="Dynamic recursive ragged arrays. ">DasAry</a> indices will be considered internal items and will be accessed as a group.</p>
<p>Having an array with an unmapped extra index is very useful for dealing with string data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMap</td><td>The mapping from dataset index positions to array index positions Any element in the map may be D2IDX_UNUSED to indicate that a particular dataset index is not used, or some value equal to or greater than 0 to indicate which array index corresponds to the i-th variable index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new variable object allocated on the heap </dd></dl>

</div>
</div>
<a class="anchor" id="ga2dfd7f7c30810e8306a656d99bcfc9fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasAry.html">DasAry</a> * DasVarAry_getArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the backing array if present. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if the variable is not backed directly by an array </dd></dl>

</div>
</div>
<a class="anchor" id="ga82b382b377d5f4dfd3148f89fcafddd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DasVar_orthoginal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getting data from a variable. </p>
<p>Answer the question: is one variable orthogonal in index space to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>pointer to the first variable object </td></tr>
    <tr><td class="paramname">pOther</td><td>pointer to the second variable object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the indicies that trigger a change in the first variable's output are completly separate from the indices that change the second variable's output </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a54a5eaecf157cef1610cfaf5efe7f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DasVar_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current shape of this variable. </p>
<p>Cause this variable to inspect it's managed array or sub-variables and determine the current extents in index space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The variable for which the shape is desired</td></tr>
    <tr><td class="paramname">pShape</td><td>a pointer to an array up to D2_MAXDIM in size. Each element of the array will be filled in with either one of the following:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>An integer from 0 to LONG_MAX to indicate the valid index range.</li>
<li>The value D2IDX_UNUSED to indicate the given index position is ignored by this variable</li>
<li>The value D2IDX_RAGGED to indicate that the valid index is variable and depends on the values of other indices.</li>
<li>The value D2IDX_FUNC to indicate that the values are not stored but rather calculated from the given index itself. This is true for variables backed by un-bounded sequences instead of arrays.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The rank of the variable, which is the number of values returned in pShape which are not marked as unused. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e2996f3508f8d42fb4534f69d55954b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DasVar_getDatum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdas__datum.html">das_datum</a> *&#160;</td>
          <td class="paramname"><em>pDatum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a value given an index. </p>
<p>This is the "slow boat from China" way to retrieve elements but it always works, even for non-orthogonal data sets, ragged arrays and variables built on expressions involving other variables. This is useful when re-gridding a data set onto a rectangular array such as a pixel or voxel raster.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>the data set in question</td></tr>
    <tr><td class="paramname">pIdx</td><td>The location to retrieve. Unmapped indices are ignored.</td></tr>
    <tr><td class="paramname">pDatum</td><td>pointer to a datum structure to fill in with the value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the indices represented by pIdx are invalid, a pointer to the data value otherwise. It is up to the caller to cast the pointer to the appropriate type and difference it to get the value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e72e7fdd5446a7595e8454ecd04f540"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DasVar_isComposite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this a simple variable or more than one variable combinded via operators? </p>
<p>If variable actually represents an expression tree of variables combined via operations </p>

</div>
</div>
<a class="anchor" id="ga01aac56dce4993ba2c9c28b31f6afdb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dec_DasVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasVar.html">DasVar</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement the reference count on a variable. </p>
<p>If the reference count of a variable drops to zero then the variable decrements the reference count on all other variables and arrays that it may be using and then free's it's own memory.</p>
<p>You should set any local pointers refering to this variable to NULL after calling dec_DasVar as it may no longer exist. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
