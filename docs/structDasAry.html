<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libdas2: DasAry Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="das2logo-32.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">libdas2
   </div>
   <div id="projectbrief">das2 core C utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">DasAry Struct Reference<div class="ingroups"><a class="el" href="group__datasets.html">Datasets</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="array_8h_source.html">das2/array.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Dynamic recursive ragged arrays. </p>
<p>This class maps any number of indices, (i,j,k...) to elements stored into a continuous array. Any or all particular index in the array can be ragged, if desired, though typically for data streams only the first index has an arbitrary length.</p>
<p>The backing buffers for the array grows if needed as new elements are appended. Individual elements may be arbitrary composite types, though extra capabilites are provided for a handful of know types.</p>
<div class="fragment"><div class="line">*</div>
<div class="line">* <span class="comment">// For this example, assume the file below consists of big endian floats</span></div>
<div class="line">* <span class="keyword">const</span> <span class="keywordtype">char</span>* my_file = <span class="stringliteral">&quot;my_big_endian_datafile.dat&quot;</span>;</div>
<div class="line">* FILE* in_file = fopen(my_file, <span class="stringliteral">&quot;rb&quot;</span>);</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// The following Rank 2 array is initially 0 records long and has</span></div>
<div class="line">* <span class="comment">// 152 values per record.  Thus it starts as a 0 by 152 array</span></div>
<div class="line">* Array* pAry = new_Array(<span class="stringliteral">&quot;amplitudes&quot;</span>, etFloat, 0, NULL, RANK_2(0, 152));</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Set byte order for input values.  This will trigger swapping if host</span></div>
<div class="line">* <span class="comment">// byte order is different from input order.  Note that this only works</span></div>
<div class="line">* <span class="comment">// for the types in the element_type enumeration.  For unknown types you&#39;ll</span></div>
<div class="line">* <span class="comment">// have to do your own byte swapping.</span></div>
<div class="line">* Array_inputBO(pAry, DAS2ARY_BIG_ENDIAN);</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Read values into the array</span></div>
<div class="line">* <span class="keywordtype">float</span> buf[152] = {0.0f};</div>
<div class="line">* <span class="keywordflow">while</span>(fread(buf, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), 152, in_file) == 152)</div>
<div class="line">*   Array_append(pAry, buf, 152);</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Get the shape of the first index.</span></div>
<div class="line">* printf(<span class="stringliteral">&quot;%d records read from %s\n&quot;</span>, Array_lengthIn(pAry, DIM0), my_file);</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Print the values in the array, loop below works with ragged arrays and</span></div>
<div class="line">* <span class="comment">// reduces function call overhead by accessing a full record at a time</span></div>
<div class="line">* <span class="keywordtype">float</span>* pVals;</div>
<div class="line">* <span class="keywordtype">size_t</span> uVals;</div>
<div class="line">* <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; Array_lengthIn(pAry, DIM0); ++i){</div>
<div class="line">*    pVals = Array_getFloatsIn(pAry, DIM1_AT(i), &amp;uVals);</div>
<div class="line">*    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> j = 0; j &lt; uVals; ++j){</div>
<div class="line">*      <span class="keywordflow">if</span>( j &gt; 0) printf(<span class="stringliteral">&quot;, &quot;</span>);</div>
<div class="line">*      printf(<span class="stringliteral">&quot;%.4e&quot;</span>, pVals[j]);</div>
<div class="line">*    }</div>
<div class="line">*    printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a266e595878d6dc350f9e45d907e39511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a266e595878d6dc350f9e45d907e39511">new_DasAry</a> (const char *id, <a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> et, size_t sz_each, const void *fill, int rank, size_t *shape, <a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a> units)</td></tr>
<tr class="memdesc:a266e595878d6dc350f9e45d907e39511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new dynamic array buffer.  <a href="#a266e595878d6dc350f9e45d907e39511">More...</a><br/></td></tr>
<tr class="separator:a266e595878d6dc350f9e45d907e39511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061ba2732f109772b8ab50cc168527a2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a061ba2732f109772b8ab50cc168527a2">DasAry_setUsage</a> (<a class="el" href="structDasAry.html">DasAry</a> *pThis, unsigned int uFlags)</td></tr>
<tr class="memdesc:a061ba2732f109772b8ab50cc168527a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set usage flags to assist arbitrary consumers understand how to use this array.  <a href="#a061ba2732f109772b8ab50cc168527a2">More...</a><br/></td></tr>
<tr class="separator:a061ba2732f109772b8ab50cc168527a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e9a69568613edac7b4af75684cbcb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55e9a69568613edac7b4af75684cbcb0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a55e9a69568613edac7b4af75684cbcb0">DasAry_getUsage</a> (<a class="el" href="structDasAry.html">DasAry</a> *pThis)</td></tr>
<tr class="memdesc:a55e9a69568613edac7b4af75684cbcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the usage flags for this array. <br/></td></tr>
<tr class="separator:a55e9a69568613edac7b4af75684cbcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0229ceac1cca3435b61a8d5bf32425e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a0229ceac1cca3435b61a8d5bf32425e1">inc_DasAry</a> (<a class="el" href="structDasAry.html">DasAry</a> *pThis)</td></tr>
<tr class="memdesc:a0229ceac1cca3435b61a8d5bf32425e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the count of objects using this Das Array.  <a href="#a0229ceac1cca3435b61a8d5bf32425e1">More...</a><br/></td></tr>
<tr class="separator:a0229ceac1cca3435b61a8d5bf32425e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894f9d1ebb66cc110a0f3a818b7dd498"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a894f9d1ebb66cc110a0f3a818b7dd498"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a894f9d1ebb66cc110a0f3a818b7dd498">ref_DasAry</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis)</td></tr>
<tr class="memdesc:a894f9d1ebb66cc110a0f3a818b7dd498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference count of objects using this array. <br/></td></tr>
<tr class="separator:a894f9d1ebb66cc110a0f3a818b7dd498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2948939f012a6dc86ffcf987dda2591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#ad2948939f012a6dc86ffcf987dda2591">dec_DasAry</a> (<a class="el" href="structDasAry.html">DasAry</a> *pThis)</td></tr>
<tr class="memdesc:ad2948939f012a6dc86ffcf987dda2591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maybe remove the array.  <a href="#ad2948939f012a6dc86ffcf987dda2591">More...</a><br/></td></tr>
<tr class="separator:ad2948939f012a6dc86ffcf987dda2591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a61d5c70373d41f838af7de0282d33f"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a0a61d5c70373d41f838af7de0282d33f">DasAry_disownElements</a> (<a class="el" href="structDasAry.html">DasAry</a> *pThis, size_t *pLen)</td></tr>
<tr class="memdesc:a0a61d5c70373d41f838af7de0282d33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove ownership of the underlying element array from this DasArray.  <a href="#a0a61d5c70373d41f838af7de0282d33f">More...</a><br/></td></tr>
<tr class="separator:a0a61d5c70373d41f838af7de0282d33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf2e551e4fb8f72580d44e4b6b718ca"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#afcf2e551e4fb8f72580d44e4b6b718ca">DasAry_id</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis)</td></tr>
<tr class="memdesc:afcf2e551e4fb8f72580d44e4b6b718ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of an array.  <a href="#afcf2e551e4fb8f72580d44e4b6b718ca">More...</a><br/></td></tr>
<tr class="separator:afcf2e551e4fb8f72580d44e4b6b718ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad490191d5479f02eccb85fe2c3ee5791"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#ad490191d5479f02eccb85fe2c3ee5791">DasAry_rank</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis)</td></tr>
<tr class="memdesc:ad490191d5479f02eccb85fe2c3ee5791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dimensions in an array.  <a href="#ad490191d5479f02eccb85fe2c3ee5791">More...</a><br/></td></tr>
<tr class="separator:ad490191d5479f02eccb85fe2c3ee5791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf7f6c1dc6f49990e0a63a31c811a8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bf7f6c1dc6f49990e0a63a31c811a8c"></a>
<a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a5bf7f6c1dc6f49990e0a63a31c811a8c">DasAry_units</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis)</td></tr>
<tr class="memdesc:a5bf7f6c1dc6f49990e0a63a31c811a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the units for the values in the array. <br/></td></tr>
<tr class="separator:a5bf7f6c1dc6f49990e0a63a31c811a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0925e6990f27d57d0a1b67490649dbfd"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a0925e6990f27d57d0a1b67490649dbfd">DasAry_valType</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis)</td></tr>
<tr class="memdesc:a0925e6990f27d57d0a1b67490649dbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of value stored in the array if known.  <a href="#a0925e6990f27d57d0a1b67490649dbfd">More...</a><br/></td></tr>
<tr class="separator:a0925e6990f27d57d0a1b67490649dbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18e85f8a4ba731fa38ec59422e7240c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac18e85f8a4ba731fa38ec59422e7240c"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#ac18e85f8a4ba731fa38ec59422e7240c">DasAry_valTypeStr</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis)</td></tr>
<tr class="memdesc:ac18e85f8a4ba731fa38ec59422e7240c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of value stored in the array as a text string. <br/></td></tr>
<tr class="separator:ac18e85f8a4ba731fa38ec59422e7240c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b386fc26feb18869d1d0aa775c8ef7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#aa9b386fc26feb18869d1d0aa775c8ef7">DasAry_toStr</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis, char *sInfo, size_t uLen)</td></tr>
<tr class="memdesc:aa9b386fc26feb18869d1d0aa775c8ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a informational string representing the array.  <a href="#aa9b386fc26feb18869d1d0aa775c8ef7">More...</a><br/></td></tr>
<tr class="separator:aa9b386fc26feb18869d1d0aa775c8ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ea761a44163ee21fa51389b083049a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a07ea761a44163ee21fa51389b083049a">DasAry_size</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis)</td></tr>
<tr class="memdesc:a07ea761a44163ee21fa51389b083049a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of data values in an array, regardless of it's shape.  <a href="#a07ea761a44163ee21fa51389b083049a">More...</a><br/></td></tr>
<tr class="separator:a07ea761a44163ee21fa51389b083049a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab218b7b16338ce948afb3159a56e054a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#ab218b7b16338ce948afb3159a56e054a">DasAry_valSize</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis)</td></tr>
<tr class="memdesc:ab218b7b16338ce948afb3159a56e054a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size in bytes of each element stored in the das array.  <a href="#ab218b7b16338ce948afb3159a56e054a">More...</a><br/></td></tr>
<tr class="separator:ab218b7b16338ce948afb3159a56e054a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba8aae921ce4e1087dfb2d946174dcb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#aeba8aae921ce4e1087dfb2d946174dcb">DasAry_lengthIn</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis, int nIdx, ptrdiff_t *pLoc)</td></tr>
<tr class="memdesc:aeba8aae921ce4e1087dfb2d946174dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current max value + 1 for any index.  <a href="#aeba8aae921ce4e1087dfb2d946174dcb">More...</a><br/></td></tr>
<tr class="separator:aeba8aae921ce4e1087dfb2d946174dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7869853b13b16488664c27f16396adbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a7869853b13b16488664c27f16396adbb">DasAry_shape</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis, ptrdiff_t *pShape)</td></tr>
<tr class="memdesc:a7869853b13b16488664c27f16396adbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current valid ranges for this array indices.  <a href="#a7869853b13b16488664c27f16396adbb">More...</a><br/></td></tr>
<tr class="separator:a7869853b13b16488664c27f16396adbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78576750f7e5100b1fe4bfda6daeb04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#ae78576750f7e5100b1fe4bfda6daeb04">DasAry_validAt</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis, ptrdiff_t *pLoc)</td></tr>
<tr class="memdesc:ae78576750f7e5100b1fe4bfda6daeb04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a valid item located at a complete index.  <a href="#ae78576750f7e5100b1fe4bfda6daeb04">More...</a><br/></td></tr>
<tr class="separator:ae78576750f7e5100b1fe4bfda6daeb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ef664de07d7e15a71e18e1518753b5"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#ab4ef664de07d7e15a71e18e1518753b5">DasAry_getAt</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis, <a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> et, ptrdiff_t *pLoc)</td></tr>
<tr class="memdesc:ab4ef664de07d7e15a71e18e1518753b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to an element at a complete index.  <a href="#ab4ef664de07d7e15a71e18e1518753b5">More...</a><br/></td></tr>
<tr class="separator:ab4ef664de07d7e15a71e18e1518753b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427108cd596b67bc6a07bd52365f5540"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a427108cd596b67bc6a07bd52365f5540">DasAry_getFloatAt</a>(pThis, pLoc)&#160;&#160;&#160;*((float*)(<a class="el" href="structDasAry.html#ab4ef664de07d7e15a71e18e1518753b5">DasAry_getAt</a>(pThis, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530a2dde9d0564f21ee871eadd6a45fc59db">vtFloat</a>, pLoc)))</td></tr>
<tr class="memdesc:a427108cd596b67bc6a07bd52365f5540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Array_get for IEEE-754 binary32 (float)  <a href="#a427108cd596b67bc6a07bd52365f5540">More...</a><br/></td></tr>
<tr class="separator:a427108cd596b67bc6a07bd52365f5540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ff132ed5997872e219fcf60f350b8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a96ff132ed5997872e219fcf60f350b8f">DasAry_getDoubleAt</a>(pThis, pLoc)&#160;&#160;&#160;*((double*)(<a class="el" href="structDasAry.html#ab4ef664de07d7e15a71e18e1518753b5">DasAry_getAt</a>(pThis, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530afd6ca1d04415b7534d47a76ddd27aca8">vtDouble</a>, pLoc)))</td></tr>
<tr class="memdesc:a96ff132ed5997872e219fcf60f350b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Array_get for IEEE-754 binary64 (double)  <a href="#a96ff132ed5997872e219fcf60f350b8f">More...</a><br/></td></tr>
<tr class="separator:a96ff132ed5997872e219fcf60f350b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19803cb42b141f014d568298c7dfa3c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a19803cb42b141f014d568298c7dfa3c2">DasAry_getByteAt</a>(pThis, pLoc)&#160;&#160;&#160;*((byte*)(<a class="el" href="structDasAry.html#ab4ef664de07d7e15a71e18e1518753b5">DasAry_getAt</a>(pThis, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530a0b48e9f85996bca01cbc4ef867a14d87">vtByte</a>, pLoc)))</td></tr>
<tr class="memdesc:a19803cb42b141f014d568298c7dfa3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Array_get for unsigned bytes.  <a href="#a19803cb42b141f014d568298c7dfa3c2">More...</a><br/></td></tr>
<tr class="separator:a19803cb42b141f014d568298c7dfa3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d392e969e1f35cc2d0ee15dfdad984"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a84d392e969e1f35cc2d0ee15dfdad984">DasAry_getUShortAt</a>(pThis, pLoc)&#160;&#160;&#160;*((uint16_t*)(<a class="el" href="structDasAry.html#ab4ef664de07d7e15a71e18e1518753b5">DasAry_getAt</a>(pThis, etUint16, pLoc)))</td></tr>
<tr class="memdesc:a84d392e969e1f35cc2d0ee15dfdad984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Array_get for unsigned 16-bit integers.  <a href="#a84d392e969e1f35cc2d0ee15dfdad984">More...</a><br/></td></tr>
<tr class="separator:a84d392e969e1f35cc2d0ee15dfdad984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcff99aef3156e966c543930e43fa06c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#abcff99aef3156e966c543930e43fa06c">DasAry_getShortAt</a>(pThis, pLoc)&#160;&#160;&#160;*((int16_t*)(<a class="el" href="structDasAry.html#ab4ef664de07d7e15a71e18e1518753b5">DasAry_getAt</a>(pThis, etInt16, pLoc)))</td></tr>
<tr class="memdesc:abcff99aef3156e966c543930e43fa06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Array_get for signed 16-bit integers.  <a href="#abcff99aef3156e966c543930e43fa06c">More...</a><br/></td></tr>
<tr class="separator:abcff99aef3156e966c543930e43fa06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee06f77cc0c293b77b00b297e63ec28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a0ee06f77cc0c293b77b00b297e63ec28">DasAry_getIntAt</a>(pThis, pLoc)&#160;&#160;&#160;*((int32_t*)(<a class="el" href="structDasAry.html#ab4ef664de07d7e15a71e18e1518753b5">DasAry_getAt</a>(pThis, etInt32, pLoc)))</td></tr>
<tr class="memdesc:a0ee06f77cc0c293b77b00b297e63ec28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Array_get for 32-bit integers.  <a href="#a0ee06f77cc0c293b77b00b297e63ec28">More...</a><br/></td></tr>
<tr class="separator:a0ee06f77cc0c293b77b00b297e63ec28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6830abf296879c5fe0069564937bb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#afd6830abf296879c5fe0069564937bb8">DasAry_getLongAt</a>(pThis, pLoc)&#160;&#160;&#160;*((int64_t*)(<a class="el" href="structDasAry.html#ab4ef664de07d7e15a71e18e1518753b5">DasAry_getAt</a>(pThis, etInt64, pLoc)))</td></tr>
<tr class="memdesc:afd6830abf296879c5fe0069564937bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Array_get for signed 64-bit integers.  <a href="#afd6830abf296879c5fe0069564937bb8">More...</a><br/></td></tr>
<tr class="separator:afd6830abf296879c5fe0069564937bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cee1e3d3ea008b57478b3cf8841ecca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a7cee1e3d3ea008b57478b3cf8841ecca">DasAry_getTimeAt</a>(pThis, pLoc)&#160;&#160;&#160;*((<a class="el" href="structdas__time.html">das_time</a>*)(<a class="el" href="structDasAry.html#ab4ef664de07d7e15a71e18e1518753b5">DasAry_getAt</a>(pThis, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530adab1a2519cac5ff5d04d295ebc90f618">vtTime</a>, pLoc)))</td></tr>
<tr class="memdesc:a7cee1e3d3ea008b57478b3cf8841ecca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Array_get for das_time_t structures.  <a href="#a7cee1e3d3ea008b57478b3cf8841ecca">More...</a><br/></td></tr>
<tr class="separator:a7cee1e3d3ea008b57478b3cf8841ecca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9681605be03f8b52313cd6849710b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#abe9681605be03f8b52313cd6849710b7">DasAry_getTextAt</a>(pThis, pLoc)&#160;&#160;&#160;*((char**)(<a class="el" href="structDasAry.html#ab4ef664de07d7e15a71e18e1518753b5">DasAry_getAt</a>(pThis, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530aaa403f3a4de6b73d20d8ed606d1aa9ff">vtText</a>, pLoc)))</td></tr>
<tr class="memdesc:abe9681605be03f8b52313cd6849710b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Array_get for pointers to null-terminated strings.  <a href="#abe9681605be03f8b52313cd6849710b7">More...</a><br/></td></tr>
<tr class="separator:abe9681605be03f8b52313cd6849710b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d390c74d7af1d3e1e946483a67dc11b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a6d390c74d7af1d3e1e946483a67dc11b">DasAry_putAt</a> (<a class="el" href="structDasAry.html">DasAry</a> *pThis, ptrdiff_t *pStart, const void *pVals, size_t uVals)</td></tr>
<tr class="memdesc:a6d390c74d7af1d3e1e946483a67dc11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set values starting at a complete index.  <a href="#a6d390c74d7af1d3e1e946483a67dc11b">More...</a><br/></td></tr>
<tr class="separator:a6d390c74d7af1d3e1e946483a67dc11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d70027b0ad586d0a6f786be47ee7768"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a7d70027b0ad586d0a6f786be47ee7768">DasAry_getIn</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis, <a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> et, int nDim, ptrdiff_t *pLoc, size_t *pCount)</td></tr>
<tr class="memdesc:a7d70027b0ad586d0a6f786be47ee7768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the elements contained by a partial index.  <a href="#a7d70027b0ad586d0a6f786be47ee7768">More...</a><br/></td></tr>
<tr class="separator:a7d70027b0ad586d0a6f786be47ee7768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad05dbecc66a8f437a62c1d986bf318"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a8ad05dbecc66a8f437a62c1d986bf318">DasAry_getFloatsIn</a>(T,...)&#160;&#160;&#160;(const float*) <a class="el" href="structDasAry.html#a7d70027b0ad586d0a6f786be47ee7768">DasAry_getIn</a>(T, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530a2dde9d0564f21ee871eadd6a45fc59db">vtFloat</a>, __VA_ARGS__)</td></tr>
<tr class="memdesc:a8ad05dbecc66a8f437a62c1d986bf318"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Array_getIn that casts the output and preforms type checking.  <a href="#a8ad05dbecc66a8f437a62c1d986bf318">More...</a><br/></td></tr>
<tr class="separator:a8ad05dbecc66a8f437a62c1d986bf318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356140a0977e5eaf1f404d45ac534034"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a356140a0977e5eaf1f404d45ac534034">DasAry_getDoublesIn</a>(T,...)&#160;&#160;&#160;(const double*) <a class="el" href="structDasAry.html#a7d70027b0ad586d0a6f786be47ee7768">DasAry_getIn</a>(T, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530afd6ca1d04415b7534d47a76ddd27aca8">vtDouble</a>, __VA_ARGS__)</td></tr>
<tr class="memdesc:a356140a0977e5eaf1f404d45ac534034"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Array_getIn that casts the output and preforms type checking.  <a href="#a356140a0977e5eaf1f404d45ac534034">More...</a><br/></td></tr>
<tr class="separator:a356140a0977e5eaf1f404d45ac534034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f2694b4a87e561a0f7844d86ded730"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a36f2694b4a87e561a0f7844d86ded730">DasAry_getBytesIn</a>(T,...)&#160;&#160;&#160;(const byte*) <a class="el" href="structDasAry.html#a7d70027b0ad586d0a6f786be47ee7768">DasAry_getIn</a>(T, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530a0b48e9f85996bca01cbc4ef867a14d87">vtByte</a>, __VA_ARGS__)</td></tr>
<tr class="memdesc:a36f2694b4a87e561a0f7844d86ded730"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Array_getIn that casts the output and preforms type checking.  <a href="#a36f2694b4a87e561a0f7844d86ded730">More...</a><br/></td></tr>
<tr class="separator:a36f2694b4a87e561a0f7844d86ded730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fea3450930ad82f95786397343c836"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a42fea3450930ad82f95786397343c836">DasAry_getUShortsIn</a>(T,...)&#160;&#160;&#160;(const uint16_t*) <a class="el" href="structDasAry.html#a7d70027b0ad586d0a6f786be47ee7768">DasAry_getIn</a>(T, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530ac447f3d9dd9e4b250990ede36457e9c6">vtUShort</a>, __VA_ARGS__)</td></tr>
<tr class="memdesc:a42fea3450930ad82f95786397343c836"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Array_getIn that casts the output and preforms type checking.  <a href="#a42fea3450930ad82f95786397343c836">More...</a><br/></td></tr>
<tr class="separator:a42fea3450930ad82f95786397343c836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e692b47c683551c7f8a27313f916f9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a9e692b47c683551c7f8a27313f916f9f">DasAry_getShortsIn</a>(T,...)&#160;&#160;&#160;(const int16_t*) <a class="el" href="structDasAry.html#a7d70027b0ad586d0a6f786be47ee7768">DasAry_getIn</a>(T, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530a0fe203efac33a548bb0793cbd6a4be9f">vtShort</a>, __VA_ARGS__)</td></tr>
<tr class="memdesc:a9e692b47c683551c7f8a27313f916f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Array_getIn that casts the output and preforms type checking.  <a href="#a9e692b47c683551c7f8a27313f916f9f">More...</a><br/></td></tr>
<tr class="separator:a9e692b47c683551c7f8a27313f916f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6230f2ebf30661bcbd6ed9580a992989"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a6230f2ebf30661bcbd6ed9580a992989">DasAry_getLongsIn</a>(T,...)&#160;&#160;&#160;(const int64_t*) <a class="el" href="structDasAry.html#a7d70027b0ad586d0a6f786be47ee7768">DasAry_getIn</a>(T, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530aa6df9ef15e5ff7578d1691627921c141">vtLong</a>, __VA_ARGS__)</td></tr>
<tr class="memdesc:a6230f2ebf30661bcbd6ed9580a992989"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Array_getIn that casts the output and preforms type checking.  <a href="#a6230f2ebf30661bcbd6ed9580a992989">More...</a><br/></td></tr>
<tr class="separator:a6230f2ebf30661bcbd6ed9580a992989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab668f7516702bb192130db9d360de271"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#ab668f7516702bb192130db9d360de271">DasAry_getTimesIn</a>(T,...)&#160;&#160;&#160;(const <a class="el" href="structdas__time.html">das_time</a>*) <a class="el" href="structDasAry.html#a7d70027b0ad586d0a6f786be47ee7768">DasAry_getIn</a>(T, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530adab1a2519cac5ff5d04d295ebc90f618">vtTime</a>, __VA_ARGS__)</td></tr>
<tr class="memdesc:ab668f7516702bb192130db9d360de271"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Array_getIn that casts the output and preforms type checking.  <a href="#ab668f7516702bb192130db9d360de271">More...</a><br/></td></tr>
<tr class="separator:ab668f7516702bb192130db9d360de271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb5771803c746b0400199b76ea6295a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#aefb5771803c746b0400199b76ea6295a">DasAry_getTextIn</a>(T,...)&#160;&#160;&#160;(const char**) <a class="el" href="structDasAry.html#a7d70027b0ad586d0a6f786be47ee7768">DasAry_getIn</a>(T, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530aaa403f3a4de6b73d20d8ed606d1aa9ff">vtText</a>, __VA_ARGS__)</td></tr>
<tr class="memdesc:aefb5771803c746b0400199b76ea6295a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Array_getIn that casts the output and preforms type checking.  <a href="#aefb5771803c746b0400199b76ea6295a">More...</a><br/></td></tr>
<tr class="separator:aefb5771803c746b0400199b76ea6295a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbd55cc90e070e9aa893dd0f7897f41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a9dbd55cc90e070e9aa893dd0f7897f41">DasAry_subSetIn</a> (const <a class="el" href="structDasAry.html">DasAry</a> *pThis, const char *id, int nIndices, ptrdiff_t *pLoc)</td></tr>
<tr class="memdesc:a9dbd55cc90e070e9aa893dd0f7897f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a lower rank array that is a sub-set of the current array.  <a href="#a9dbd55cc90e070e9aa893dd0f7897f41">More...</a><br/></td></tr>
<tr class="separator:a9dbd55cc90e070e9aa893dd0f7897f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e474ecf5051eb7dc6980278b70e37c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a3e474ecf5051eb7dc6980278b70e37c3">DasAry_qubeIn</a> (<a class="el" href="structDasAry.html">DasAry</a> *pThis, int iRecDim)</td></tr>
<tr class="memdesc:a3e474ecf5051eb7dc6980278b70e37c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use fill values to make sure the last subset in a dimension is a QUBE.  <a href="#a3e474ecf5051eb7dc6980278b70e37c3">More...</a><br/></td></tr>
<tr class="separator:a3e474ecf5051eb7dc6980278b70e37c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c52a30e19d0a70759591a5bc4185adc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a6c52a30e19d0a70759591a5bc4185adc">DasAry_append</a> (<a class="el" href="structDasAry.html">DasAry</a> *pThis, const void *pVals, size_t uCount)</td></tr>
<tr class="memdesc:a6c52a30e19d0a70759591a5bc4185adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append some number of items to the end of the array.  <a href="#a6c52a30e19d0a70759591a5bc4185adc">More...</a><br/></td></tr>
<tr class="separator:a6c52a30e19d0a70759591a5bc4185adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22df6187b4e0d236db414aa341d3807d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a22df6187b4e0d236db414aa341d3807d">DasAry_markEnd</a> (<a class="el" href="structDasAry.html">DasAry</a> *pThis, int iDim)</td></tr>
<tr class="memdesc:a22df6187b4e0d236db414aa341d3807d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a ragged dimension as finished.  <a href="#a22df6187b4e0d236db414aa341d3807d">More...</a><br/></td></tr>
<tr class="separator:a22df6187b4e0d236db414aa341d3807d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7718b63d47d49b4792f4cb85c0c0acb0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a7718b63d47d49b4792f4cb85c0c0acb0">DasAry_clear</a> (<a class="el" href="structDasAry.html">DasAry</a> *pThis)</td></tr>
<tr class="memdesc:a7718b63d47d49b4792f4cb85c0c0acb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all values from the array.  <a href="#a7718b63d47d49b4792f4cb85c0c0acb0">More...</a><br/></td></tr>
<tr class="separator:a7718b63d47d49b4792f4cb85c0c0acb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3947a8d1bb660050042f5a9b97dabdf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#ac3947a8d1bb660050042f5a9b97dabdf">DasAry_cmp</a> (<a class="el" href="structDasAry.html">DasAry</a> *pThis, const void *vpFirst, const void *vpSecond)</td></tr>
<tr class="memdesc:ac3947a8d1bb660050042f5a9b97dabdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two items of the type in the array.  <a href="#ac3947a8d1bb660050042f5a9b97dabdf">More...</a><br/></td></tr>
<tr class="separator:ac3947a8d1bb660050042f5a9b97dabdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5a7c00868a887152a309b05f2f5e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasAry.html#a9e5a7c00868a887152a309b05f2f5e55">DasAry_setSrc</a> (<a class="el" href="structDasAry.html">DasAry</a> *pThis, int nPktId, size_t uStartItem, size_t uItems)</td></tr>
<tr class="memdesc:a9e5a7c00868a887152a309b05f2f5e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record which packets contain data destine for this array.  <a href="#a9e5a7c00868a887152a309b05f2f5e55">More...</a><br/></td></tr>
<tr class="separator:a9e5a7c00868a887152a309b05f2f5e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a266e595878d6dc350f9e45d907e39511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasAry.html">DasAry</a> * new_DasAry </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a>&#160;</td>
          <td class="paramname"><em>et</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz_each</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a>&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new dynamic array buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The name of this array. This may be used as a lookup key if an array pointer is stored in a lookup table.</td></tr>
    <tr><td class="paramname">et</td><td>The element type, for arbitrary element storage use UNKNOWN, specific types are provided in enum element_type.</td></tr>
    <tr><td class="paramname">sz_each</td><td>The size of each element in the array in bytes. This parameter is only used when the element type is unknown.</td></tr>
    <tr><td class="paramname">fill</td><td>A pointer to the value for initializing all empty array records. The value should be size_each bytes long. These bytes are copied into the array and this pointer need not remain valid after the constructor call. For unknown types (et = etUnknown) this is a required, non NULL parameter. For known types you can use NULL to automatically set fill to the following values, based on the element_type:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>etByte 0</li>
<li>etUShort 65535</li>
<li>etShort -32767</li>
<li>etInt -2147483647</li>
<li>etLong -9223372036854775807L</li>
<li>etFloat -1.0e31</li>
<li>etDouble -1.0e31</li>
<li>etTime 0000-01-01T00:00:00.000</li>
</ul>
<p>pFill can point to stack memory as the fill bytes are copied in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>The number of dimensions in the array. This sets the number of arguments needed in the get() function call. To make your code easier to read, the defines RANK_1, RANK_2, ... RANK_16 are provided.</td></tr>
    <tr><td class="paramname">shape</td><td>The initial shape of the array. One integer is needed here for each dimension in the array. Use the value 0 to set a dimension to be unbounded. Multi-dimension arrays used to hold an arbitrarily long set of records are typically only unbounded in the first index, though see the example in Array_markEnd for handling multiply ragged arrays.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new array buffer allocated on the heap.</dd></dl>
<div class="fragment"><div class="line">*    <span class="comment">// Create a rank 3 array that is ragged only in the first index, with a</span></div>
<div class="line">*    <span class="comment">// fill value of -1.0f, useful for storing a stream of fixed size MARSIS</span></div>
<div class="line">*    <span class="comment">// AIS records</span></div>
<div class="line">*    <span class="keywordtype">float</span> fill = -1.0f;</div>
<div class="line">*    Array* pA = new_Array(<span class="stringliteral">&quot;fee&quot;</span>, etFloat, 0, &amp;fill, RANK_3(0,160,80));</div>
<div class="line">*</div>
<div class="line">*    <span class="comment">// Create an empty Rank 2 array, that is ragged in both indices.</span></div>
<div class="line">*    <span class="comment">// (Useful for Cassini WBR data)</span></div>
<div class="line">*    Array* pA = new_Array(<span class="stringliteral">&quot;fi&quot;</span>, etFloat, 0, NULL, RANK_2(0,0));</div>
<div class="line">*</div>
<div class="line">*    <span class="comment">// Theoretical example of creating a triply ragged array to hold</span></div>
<div class="line">*    <span class="comment">// text from a document, where the first index is the page the</span></div>
<div class="line">*    <span class="comment">// second is the line and the third is the byte in a line</span></div>
<div class="line">*    Array* pA = new_Array(<span class="stringliteral">&quot;text&quot;</span>, etByte, 0, NULL, RANK_3(0,0,0));</div>
<div class="line">*</div>
<div class="line">* </div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The number of shape parameters must be equal to the rank of the array. The compiler <b>can't</b> check this, but you <b> will get segfaults </b> if the value of rank does not match the number of shape values. To help avoid this the use of the RANK_* macros is highly recommended. </dd></dl>

</div>
</div>
<a class="anchor" id="a061ba2732f109772b8ab50cc168527a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int DasAry_setUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>uFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set usage flags to assist arbitrary consumers understand how to use this array. </p>
<p>Das2 arrays can store co-opertive flags, these do not change the array API but do indicate how the array should be used. The following two usage flags are currently defined:</p>
<ul>
<li>D2ARY_AS_SUBSEQ : Contains Sub-sequences</li>
<li>D2ARY_FILL_TERM : Contains FILL terminated sub-sequences</li>
<li>D2ARY_AS_STRING : Contains FILL terminated sub-sequences and FILL is 0</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td></td></tr>
    <tr><td class="paramname">uFlags</td><td>A flag value to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old flag setting </dd></dl>

</div>
</div>
<a class="anchor" id="a0229ceac1cca3435b61a8d5bf32425e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int inc_DasAry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the count of objects using this Das Array. </p>
<dl class="section return"><dt>Returns</dt><dd>The new count. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2948939f012a6dc86ffcf987dda2591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dec_DasAry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maybe remove the array. </p>
<p>Calling this function decrements the reference count for the array. If the count reaches zero all backing buffers (owned by this array) are deleted. </p>

</div>
</div>
<a class="anchor" id="a0a61d5c70373d41f838af7de0282d33f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte * DasAry_disownElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove ownership of the underlying element array from this DasArray. </p>
<p>Internally all Das Array elements are stored in a single continuous 1-D buffer. When the Das Array is deleted, this buffer is removed as well, if it's owned by the das array.</p>
<p>Implementation detail, the index tracking arrays may still be owned by the Array object and will be deleted when the overall structure is deleted</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to a das array structure</td></tr>
    <tr><td class="paramname">pLen</td><td>A pointer to a variable to hold the length of the element array in elements (not bytes). Use this value to distingu</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the raw 1-D element buffer if the Array actually owned the elements, NULL otherwise. Note that buffer memory is not allocated until elements are inserted (lazy allocation) thus an empty array WILL NOT own any elements. So this this function will ALWAYS return NULL for an empty array. Use the value returned by pLen to see if the NULL return was because the array didn't own it's elements or if there were no elements to own. </dd></dl>

</div>
</div>
<a class="anchor" id="afcf2e551e4fb8f72580d44e4b6b718ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * DasAry_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A constant pointer to this array structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant pointer to the identifier for the array </dd></dl>

</div>
</div>
<a class="anchor" id="ad490191d5479f02eccb85fe2c3ee5791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DasAry_rank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of dimensions in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>a pointer to a das array structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value greater than 0 giving the number of dimensions in the array </dd></dl>

</div>
</div>
<a class="anchor" id="a0925e6990f27d57d0a1b67490649dbfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> DasAry_valType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of value stored in the array if known. </p>
<p>This function is used by dataset objects to know how to cast pointers to different data array values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A constant pointer to this array structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant pointer to string containing the name for the values in the array, or NULL if the value type has not been set. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9b386fc26feb18869d1d0aa775c8ef7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * DasAry_toStr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a informational string representing the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The Array in question </td></tr>
    <tr><td class="paramname">sInfo</td><td>pointer to the destination to hold the info string </td></tr>
    <tr><td class="paramname">uLen</td><td>the length of the sInfo buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer sInfo </dd></dl>

</div>
</div>
<a class="anchor" id="a07ea761a44163ee21fa51389b083049a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t DasAry_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of data values in an array, regardless of it's shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A constant pointer to this array structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of items stored in the array, regardless of it's shape. </dd></dl>

</div>
</div>
<a class="anchor" id="ab218b7b16338ce948afb3159a56e054a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t DasAry_valSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size in bytes of each element stored in the das array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The Array in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of each element in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="aeba8aae921ce4e1087dfb2d946174dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t DasAry_lengthIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current max value + 1 for any index. </p>
<p>This is a more general version of Array_shape that works for both cubic arrays and those with ragged dimensions. For any index to be inspected, the value of all previous indices must be given. This is less confusing then it sounds, see the example below</p>
<dl class="section see"><dt>See Also</dt><dd>Array_shape For simple arrays that are only ragged in the first index.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to an array object</td></tr>
    <tr><td class="paramname">nIdx</td><td>The number of location indices, should be less than the rank in order to get the length of a range of values. The macros DIM0, DIM1_AT, DIM2_AT, etc. are provided which combine this argument and the one below to make calling code more readable, see the example below.</td></tr>
    <tr><td class="paramname">pLoc</td><td>A list of the values for previous indices. The macros DIM1, DIM2_AT, DIM3_AT etc. are provided which combine this argument with the one above to make calling code more readable, see the example below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current maximum valid value for the <em>i<sup>th</sup></em> index at current location in the previous indices.</dd></dl>
<div class="fragment"><div class="line">*</div>
<div class="line">* <span class="comment">// Here pWBR is a ragged array of all waveform amplitudes taken in a single</span></div>
<div class="line">* <span class="comment">// capture.  Dimension 0 corresponds to the capture time point and dimension</span></div>
<div class="line">* <span class="comment">// 1 corresponds to each sample in a capture.</span></div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Print the number of samples in each waveform.</span></div>
<div class="line">* <span class="keywordtype">size_t</span> uWaveforms = Array_lengthIn(pWBR, DIM0);</div>
<div class="line">* <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> u = 0; u &amp;lt; uWaveforms; ++u)</div>
<div class="line">*     print(<span class="stringliteral">&quot;Capture %zu has %zu samples\n&quot;</span>, u, Array_lengthIn(pWBR, DIM1_AT(u));</div>
<div class="line">* </div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd>Array_getAt to obtain both the length and a pointer to a continuous range of data <a class="el" href="group__values.html" title="Basic data storage elements. ">Values</a> an once. </dd></dl>

</div>
</div>
<a class="anchor" id="a7869853b13b16488664c27f16396adbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DasAry_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return current valid ranges for this array indices. </p>
<dl class="section see"><dt>See Also</dt><dd>Array_lengthIn</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pThis</td><td>pointer to an array object</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pShape</td><td>pointer to an array to received the current number of entries in each dimension, should be at least RANK in length. Each element of the output array will be one of the following.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>An integer from 0 to LONG_MAX to indicate a valid index range</li>
<li>The value DASIDX_RAGGED to indicate that the valid index is variable and depends on the values of other indices.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The rank of the array. </dd></dl>

</div>
</div>
<a class="anchor" id="ae78576750f7e5100b1fe4bfda6daeb04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DasAry_validAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is a valid item located at a complete index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to the array</td></tr>
    <tr><td class="paramname">pLoc</td><td>An array of indices of length RANK. A rank 1 Das Array requires two indices to access an element, a rank 2 requires three, etc. The macros LOC_1, LOC_2, etc have been provided to make code more readable. See the example below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true the location list refers to a valid array index set. False otherwise. Not that the actual value at the index may be a fill value. <div class="fragment"><div class="line">* Array* pAry = new_Array(<span class="stringliteral">&quot;amplitudes&quot;</span>, FLOAT, NULL, RANK_3(0, 160, 80));</div>
<div class="line">*</div>
<div class="line">* <span class="keywordtype">size_t</span> uRec = 0;</div>
<div class="line">* <span class="comment">// See if we have a complete MARSIS frame for this record...</span></div>
<div class="line">* <span class="keywordflow">if</span>(! Array_validAt(pAry, IDX3(uRec, 159, 79)))</div>
<div class="line">*    fprintf(stderr, <span class="stringliteral">&quot;Error: Short frame count in record %zu&quot;</span>, uRec);</div>
<div class="line">* </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ab4ef664de07d7e15a71e18e1518753b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * DasAry_getAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a>&#160;</td>
          <td class="paramname"><em>et</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to an element at a complete index. </p>
<p>For type safety the macros Array_getFloat, Array_getDouble, etc have been provided and should be used instead of the base function here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to the array</td></tr>
    <tr><td class="paramname">et</td><td>The element type pointer expected at the given location, this is used by the type checking macros Array_getFloat and friends.</td></tr>
    <tr><td class="paramname">pLoc</td><td>An array of indices of length RANK. A rank 2 Das Array requires two indices to access an element, a rank 3 requires three, etc. The macros IDX1, IDX2, IDX3, etc have been provided to make code more readable. See the example below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to value at the given indices, or NULL if that location is not valid and <a class="el" href="group__utilities.html#ga196c8c8867d939875d66f97fdd327e41" title="Error handling: Normal Return Set the library to return normally to the calling function with a retur...">das_return_on_error()</a> has been called.</dd></dl>
<div class="fragment"><div class="line">* <span class="comment">// Uses type checking macro&#39;s</span></div>
<div class="line">* das_time_t dt = Array_getTimeAt(pAry, IDX1(uRec));</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Get last event, whereever it is</span></div>
<div class="line">* <span class="keyword">const</span> <span class="keywordtype">char</span>* sEvent = Array_getTextAt(pAry, IDX1(-1));</div>
<div class="line">* </div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd>Array_getIn to access multiple <a class="el" href="group__values.html" title="Basic data storage elements. ">Values</a> at once avoiding function call overhead in tight loops. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d390c74d7af1d3e1e946483a67dc11b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DasAry_putAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set values starting at a complete index. </p>
<p>Note, this will not expand the size of the array. Use the function append() to automatically grow the array to store the desired number of items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to the array </td></tr>
    <tr><td class="paramname">pStart</td><td>The complete index to the starting point to write values, use the macros IDX1, IDX2, etc. to make calling code more readable </td></tr>
    <tr><td class="paramname">pVals</td><td>The values to write </td></tr>
    <tr><td class="paramname">uVals</td><td>The number of values to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the items could be written, false if the array is not large enough to hold all the values or if any other error is encountered </dd></dl>

</div>
</div>
<a class="anchor" id="a7d70027b0ad586d0a6f786be47ee7768"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * DasAry_getIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a>&#160;</td>
          <td class="paramname"><em>et</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the elements contained by a partial index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A Array containing the data of interest</td></tr>
    <tr><td class="paramname">et</td><td>The expected type of element to be returned. This is used by the type safe macros Array_getDoubleAt, Array_getTextAt, etc.</td></tr>
    <tr><td class="paramname">nDim</td><td>The number of location indices, should be less than the rank in order to get the length of a range of values. The macros DIM0, DIM1_AT, DIM2_AT, etc. are provided which combine this argument and the one below to make calling code more readable, see the example below.</td></tr>
    <tr><td class="paramname">pLoc</td><td>An array of location indices, nIndices long. Use the macros DIM0, DIM1_AT, DIM2_AT, etc. for cleaner code.</td></tr>
    <tr><td class="paramname">pCount</td><td>A pointer to a variable to hold the number of elements under the given index. If nIndices is equal to the array rank the returned value will be at most 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer a continuous subset of elements, or NULL if no elements are located at the given index set. You will have to cast this pointer to the element type.</dd></dl>
<div class="fragment"><div class="line">* <span class="comment">// Print all the events in an array</span></div>
<div class="line">* <span class="keywordtype">size_t</span> uVals;</div>
<div class="line">* <span class="keywordtype">char</span>** events = Array_getTextIn(pAry, DIM1, &amp;uVals);</div>
<div class="line">* <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> u = 0; u &lt; uVals; ++u)</div>
<div class="line">*    printf(<span class="stringliteral">&quot;Event %06zu: %s\n&quot;</span>, u, events[u]);</div>
<div class="line">* </div>
</div><!-- fragment --><div class="fragment"><div class="line">* <span class="comment">// Print all the magnetic amplitudes for a single time slice at index 117</span></div>
<div class="line">* <span class="keywordtype">size_t</span> uVals;</div>
<div class="line">* <span class="keywordtype">float</span>* pAmp = Array_getFloatsIn(pAry, DIM2_AT(117), &amp;uVals);</div>
<div class="line">* <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> u = 0; u &lt; uVals; ++u)</div>
<div class="line">*    printf(<span class="stringliteral">&quot;Amp at freq %03zu: %s nT**2/Hz \n&quot;</span>, u, events[u]);</div>
<div class="line">*</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9dbd55cc90e070e9aa893dd0f7897f41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDasAry.html">DasAry</a> * DasAry_subSetIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t *&#160;</td>
          <td class="paramname"><em>pLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a lower rank array that is a sub-set of the current array. </p>
<p>For some given number of indices, produce a sub-array. This is similar to Array_getAt but produces a whole new Array object whose data are provided stored in a separate Array.</p>
<div class="fragment"><div class="line">* <span class="comment">// Get all data for the 10th record of a 2-D dataset, would often be a</span></div>
<div class="line">* <span class="comment">// time slice for das2 streams.</span></div>
<div class="line">* Array* pRec = Array_subSetIn(pAllData, INDEX_0, 10);</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Get the time delays for frequency index 100 for time point 22 of a</span></div>
<div class="line">* <span class="comment">// MARSIS AIS data stream</span></div>
<div class="line">* Array* pDelays = Array_subSetIn(pAllData, INDEX_1, 22, 100);</div>
<div class="line">* </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td></td></tr>
    <tr><td class="paramname">id</td><td>A identifing name for the new sub-array</td></tr>
    <tr><td class="paramname">nIndices</td><td>The number of location indices, should be less than the rank in order to get a range of values. Use the macros DIM0, DIM1_AT, DIM2_AT, etc. for cleaner code.</td></tr>
    <tr><td class="paramname">pLoc</td><td>An array of location indices, nIndices long. Use the macros DIM0, DIM1_AT, DIM2_AT, etc. for cleaner code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Array allocated on the heap that does not own it's backing buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e474ecf5051eb7dc6980278b70e37c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t DasAry_qubeIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iRecDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use fill values to make sure the last subset in a dimension is a QUBE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>the array</td></tr>
    <tr><td class="paramname">iRecDim</td><td>The dimension to qube, typically the last dimension in the array, dimensions are numbered starting from 0. Use the macro's DIM1, DIM2, etc. to make the code more readable. Dimension 0 can't be marked as ended and the macro DIM0 will not work here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of fill values added to the array</dd></dl>
<div class="fragment"><div class="line">* Array* pAry = new_Array(<span class="stringliteral">&quot;marsis&quot;</span>, etFloat, 0, NULL, RANK_3(0, 160, 80));</div>
<div class="line">*</div>
<div class="line">* <span class="comment">//Example 1: Read a complete sets of delay times</span></div>
<div class="line">* <span class="keywordtype">float</span> buf[80];</div>
<div class="line">* <span class="keywordtype">size_t</span> uRead = fread(buf, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), 80, stdin);</div>
<div class="line">* Array_append(pAry, buf, uRead);</div>
<div class="line">* Array_qubeIn(pAry, DIM2);</div>
<div class="line">*</div>
<div class="line">* <span class="comment">//Example 2: Read in complete ionograms</span></div>
<div class="line">* <span class="keywordtype">float</span> buf[160*80];</div>
<div class="line">* <span class="keywordtype">size_t</span> uRead = fread(buf, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), 80*160, stdin);</div>
<div class="line">* Array_append(pAry, buf, uRead);</div>
<div class="line">* Array_qubeIn(pAry, DIM1);</div>
<div class="line">*</div>
<div class="line">* </div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDasAry.html#a6c52a30e19d0a70759591a5bc4185adc" title="Append some number of items to the end of the array. ">DasAry_append</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6c52a30e19d0a70759591a5bc4185adc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DasAry_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append some number of items to the end of the array. </p>
<p>This works as you would expect for all arrays that are only ragged in the 0th dimension.</p>
<dl class="section see"><dt>See Also</dt><dd>Array_markEnd. Arrays that are ragged in dimension other that the 0th need some way to know that it's <a class="el" href="group__time.html" title="Parsing and converting calendar dates and times. ">Time</a> to roll the index back to 0 on the next append operation, Array_markEnd sets the needed flags.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The array which should copy in the new values. </td></tr>
    <tr><td class="paramname">pVals</td><td>A constant pointer to values to add </td></tr>
    <tr><td class="paramname">uCount</td><td>The number of values to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if uCount items were appended to the array, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a22df6187b4e0d236db414aa341d3807d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DasAry_markEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a ragged dimension as finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The das array</td></tr>
    <tr><td class="paramname">iDim</td><td>The dimension which should have it's index rolled back to zero on the next insert. Marking the end of a low index (say 1) automatically marks the end of any higher indices (ex 2,3). <div class="fragment"><div class="line">* <span class="comment">// Read in lines of text into an array that stores data by page number,</span></div>
<div class="line">* <span class="comment">// line number and the byte number.  Input processing is simplistic in</span></div>
<div class="line">* <span class="comment">// order to focus on Array calls.</span></div>
<div class="line">*</div>
<div class="line">* byte fill = 0;</div>
<div class="line">* Array* pAry = new_Array(<span class="stringliteral">&quot;source&quot;</span>, etByte, 0, &amp;fill, RANK_3(0,0,0));</div>
<div class="line">* <span class="keywordtype">char</span> sBuf[1024] = {<span class="charliteral">&#39;\0&#39;</span>};</div>
<div class="line">* <span class="keywordtype">size_t</span> uLen = 0;</div>
<div class="line">* <span class="keywordflow">while</span>(!eof(stdin)){</div>
<div class="line">*    <span class="keywordflow">while</span>(fgets(sBuf, 1024, stdin)){</div>
<div class="line">*       uLen = strlen(sBuf);</div>
<div class="line">*       <span class="keywordflow">if</span>(sBuf[0] == 0x0C) Array_markEnd(pAry, DIM1);        <span class="comment">// end page</span></div>
<div class="line">*        Array_append(pAry, sBuf, uLen+1);        <span class="comment">// keep NULL terminators</span></div>
<div class="line">*        <span class="keywordflow">if</span>(sBuf[uLen - 1] == <span class="charliteral">&#39;\n&#39;</span>) Array_markEnd(pAry, DIM2); <span class="comment">// end line</span></div>
<div class="line">*    }</div>
<div class="line">* }</div>
<div class="line">* </div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7718b63d47d49b4792f4cb85c0c0acb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t DasAry_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all values from the array. </p>
<p>This operation internally just resets the count of items to 0 in all arrays it does not free memory. Dimensions above the 0th retain their shape.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The array to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>then number of items cleared </dd></dl>

</div>
</div>
<a class="anchor" id="ac3947a8d1bb660050042f5a9b97dabdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DasAry_cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vpFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vpSecond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two items of the type in the array. </p>
<dl class="section return"><dt>Returns</dt><dd>A value less than zero if *pFirst is less than *pSecond, a value greater than zero if *pFirst is greater than *pSecond and 0 if both values are equal </dd></dl>

</div>
</div>
<a class="anchor" id="a9e5a7c00868a887152a309b05f2f5e55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DasAry_setSrc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasAry.html">DasAry</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPktId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uStartItem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uItems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record which packets contain data destine for this array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The array </td></tr>
    <tr><td class="paramname">nPktId</td><td>The id of the Das packet which contains values that should be added to this array </td></tr>
    <tr><td class="paramname">uStartItem</td><td>The location in the packet where this array's data starts</td></tr>
    <tr><td class="paramname">uItems</td><td>The number of items to add from each packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>das2/<a class="el" href="array_8h_source.html">array.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
