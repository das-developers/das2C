<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libdas2: PktDesc Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="das2logo-32.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">libdas2
   </div>
   <div id="projectbrief">das2 core C utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">PktDesc Struct Reference<div class="ingroups"><a class="el" href="group__streams.html">Streams</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="packet_8h_source.html">das2/packet.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PktDesc:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structPktDesc.png" usemap="#PktDesc_map" alt=""/>
  <map id="PktDesc_map" name="PktDesc_map">
<area href="structDasDesc.html" title="Base structure for Stream Header Items. " alt="DasDesc" shape="rect" coords="0,0,63,24"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Holds information for a single packet type in a Das2 stream. </p>
<p>A Das2 Stream may consist of up to 99 different types of <em>packets</em>. In the following Das2 Stream snippet two different types of packets are defined: </p>
<div class="fragment"><div class="line">* [00]000234&lt;stream&gt;</div>
<div class="line">*   &lt;properties xMonotonic=<span class="stringliteral">&quot;true&quot;</span> xLabel=<span class="stringliteral">&quot;Time (s)&quot;</span> yLabel=<span class="stringliteral">&quot;Frequency (s!U-1!N)&quot;</span></div>
<div class="line">*               zLabel=<span class="stringliteral">&quot;Electric Field (V m!U-1!N)&quot;</span> title=<span class="stringliteral">&quot;Voyager 1 PWS SA&quot;</span></div>
<div class="line">*               Datum:xTagWidth=<span class="stringliteral">&quot;256.0 s&quot;</span> <span class="keywordtype">double</span>:zFill=<span class="stringliteral">&quot;0.0&quot;</span> /&gt;</div>
<div class="line">* &lt;/stream&gt;</div>
<div class="line">* </div>
</div><!-- fragment --> <div class="fragment"><div class="line">* [01]000201&lt;packet&gt;</div>
<div class="line">*   &lt;x type=<span class="stringliteral">&quot;time24&quot;</span> units=<span class="stringliteral">&quot;us2000&quot;</span> &gt;&lt;/x&gt;</div>
<div class="line">*   &lt;yscan name=<span class="stringliteral">&quot;averages&quot;</span> nitems=<span class="stringliteral">&quot;5&quot;</span> type=<span class="stringliteral">&quot;ascii9&quot;</span> yUnits=<span class="stringliteral">&quot;Hz&quot;</span> zUnits=<span class="stringliteral">&quot;V/m&quot;</span> </div>
<div class="line">*          yTags=<span class="stringliteral">&quot;10.0,17.8,31.1,56.2,100.0&quot;</span>&gt;</div>
<div class="line">*     &lt;properties zSummary=<span class="stringliteral">&quot;Average value within the interval&quot;</span>/&gt;</div>
<div class="line">*   &lt;/yscan&gt;</div>
<div class="line">* &lt;/packet&gt;</div>
<div class="line">* </div>
</div><!-- fragment --> <div class="fragment"><div class="line">* [02]000201&lt;packet&gt;</div>
<div class="line">*   &lt;x type=<span class="stringliteral">&quot;time24&quot;</span> units=<span class="stringliteral">&quot;us2000&quot;</span> &gt;&lt;/x&gt;</div>
<div class="line">*   &lt;yscan name=<span class="stringliteral">&quot;peaks&quot;</span> nitems=<span class="stringliteral">&quot;5&quot;</span> type=<span class="stringliteral">&quot;ascii9&quot;</span> yUnits=<span class="stringliteral">&quot;Hz&quot;</span> zUnits=<span class="stringliteral">&quot;V/m&quot;</span> </div>
<div class="line">*          yTags=<span class="stringliteral">&quot;10.0,17.8,31.1,56.2,100.0&quot;</span>&gt;</div>
<div class="line">*     &lt;properties zSummary=<span class="stringliteral">&quot;Peak value within the interval&quot;</span>/&gt;</div>
<div class="line">*   &lt;/yscan&gt;</div>
<div class="line">* &lt;/packet&gt;</div>
<div class="line">* </div>
</div><!-- fragment --> <div class="fragment"><div class="line">* :01:2012-01-01T12:56:22.792 1.91e-06 8.92e-07 7.80e-07 6.04e-07 2.43e-07</div>
<div class="line">* :02:2012-01-01T12:56:22.792 3.12e-06 4.10e-06 2.47e-06 1.42e-06 9.36e-07 </div>
<div class="line">* :01:2012-01-01T13:00:38.792 1.98e-06 4.63e-07 7.64e-07 7.56e-07 5.09e-07 </div>
<div class="line">* :02:2012-01-01T13:00:38.792 2.91e-06 1.46e-06 2.97e-06 1.42e-06 1.55e-06 </div>
<div class="line">* </div>
</div><!-- fragment --><p>Each <b>&lt;packet&gt;</b> element above is a serialized PacketDescriptor. This structure and it's associated functions are responsible for:</p>
<ol type="1">
<li>Holding the definition of a single packet type within the stream</li>
<li>Writing data values onto the stream</li>
<li>Serializing data values from a stream</li>
</ol>
<p>To help them do their jobs, PacketDescriptors hold and array of PlaneDescriptors, as well a byte field containing up to one data packet's worth of bytes.</p>
<h3>Creating Packet Descriptors</h3>
<p>Packet Descriptors are part of a Das2 Stream. To define a new packet type call: </p>
<div class="fragment"><div class="line">*  createPacketDescriptor(<a class="code" href="structStreamDesc.html">StreamDesc</a>* sd, DataType xDataType, UnitType xUnits)</div>
<div class="line">* </div>
</div><!-- fragment --><p>or a similar function. This particular version creates a PacketDescriptor that only has an &lt;x&gt; plane. Using the following to add &lt;y&gt; and/or &lt;yscan&gt; planes to the packet.</p>
<div class="fragment"><div class="line">*   addPlaneY()</div>
<div class="line">*   addPlaneYScan()</div>
<div class="line">* </div>
</div><!-- fragment --><p>Optionally additions properties such as labels may be added to each &lt;y&gt; or &lt;yscan&gt; plane using:</p>
<div class="fragment"><div class="line">*   setPropertyString()</div>
<div class="line">* </div>
</div><!-- fragment --><p>and related functions.</p>
<p>When reading Das2 Streams PacketDescriptors are created automatically as the input is read by the processStream() method of the <a class="el" href="structStreamHandler.html" title="A set of callbacks used for input and output stream processing. ">StreamHandler</a>.</p>
<h3>Emitting Packet Data</h3>
<p>The PacketDiscriptor has a 1-Packet wide buffer. This buffer is used to build up the output data for a single packet. To set the value for the various planes use:</p>
<div class="fragment"><div class="line">* setDataPacketDouble()       <span class="comment">// For &lt;x&gt; and &lt;y&gt; planes</span></div>
<div class="line">* setDataPacketYScanDouble()  <span class="comment">// For &lt;yscan&gt; planes</span></div>
<div class="line">* </div>
</div><!-- fragment --><p>and related functions. Once that job is complete, transmit the data packet using:</p>
<div class="fragment"><div class="line">* sendPacket()</div>
<div class="line">* </div>
</div><!-- fragment --><p>The details of encoding the data according the format stored in the packet descriptor are handled by the library.</p>
<h3>Reading Data</h3>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adfcda4585cee753e26aa1ffdef8baa11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#adfcda4585cee753e26aa1ffdef8baa11">new_PktDesc</a> (void)</td></tr>
<tr class="memdesc:adfcda4585cee753e26aa1ffdef8baa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a packet descriptor with the default settings.  <a href="#adfcda4585cee753e26aa1ffdef8baa11">More...</a><br/></td></tr>
<tr class="separator:adfcda4585cee753e26aa1ffdef8baa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9911a5e0b54dedcc9996439be05c581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#aa9911a5e0b54dedcc9996439be05c581">new_PktDesc_xml</a> (<a class="el" href="structDasBuf.html">DasBuf</a> *pBuf, <a class="el" href="structDasDesc.html">DasDesc</a> *pParent, int nPktId)</td></tr>
<tr class="memdesc:aa9911a5e0b54dedcc9996439be05c581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structPktDesc.html" title="Holds information for a single packet type in a Das2 stream. ">PktDesc</a> from XML data.  <a href="#aa9911a5e0b54dedcc9996439be05c581">More...</a><br/></td></tr>
<tr class="separator:aa9911a5e0b54dedcc9996439be05c581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fa1d69eec2a96208f5ba2179adb9c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#a29fa1d69eec2a96208f5ba2179adb9c3">PktDesc_getId</a> (const <a class="el" href="structPktDesc.html">PktDesc</a> *pThis)</td></tr>
<tr class="memdesc:a29fa1d69eec2a96208f5ba2179adb9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the packet ID for this packet.  <a href="#a29fa1d69eec2a96208f5ba2179adb9c3">More...</a><br/></td></tr>
<tr class="separator:a29fa1d69eec2a96208f5ba2179adb9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a7e1d9918238ef952c149031c56e48"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#ae2a7e1d9918238ef952c149031c56e48">PktDesc_getGroup</a> (const <a class="el" href="structPktDesc.html">PktDesc</a> *pThis)</td></tr>
<tr class="memdesc:ae2a7e1d9918238ef952c149031c56e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data group for this packet.  <a href="#ae2a7e1d9918238ef952c149031c56e48">More...</a><br/></td></tr>
<tr class="separator:ae2a7e1d9918238ef952c149031c56e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ca8db95981359db19c479260ab8712"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#aa7ca8db95981359db19c479260ab8712">PktDesc_setGroup</a> (<a class="el" href="structPktDesc.html">PktDesc</a> *pThis, const char *sGroup)</td></tr>
<tr class="memdesc:aa7ca8db95981359db19c479260ab8712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data group for this packet.  <a href="#aa7ca8db95981359db19c479260ab8712">More...</a><br/></td></tr>
<tr class="separator:aa7ca8db95981359db19c479260ab8712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac902719f6e9691e42d39f5228e2cfaee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#ac902719f6e9691e42d39f5228e2cfaee">PktDesc_recBytes</a> (const <a class="el" href="structPktDesc.html">PktDesc</a> *pThis)</td></tr>
<tr class="memdesc:ac902719f6e9691e42d39f5228e2cfaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of data records defined by a packet descriptor.  <a href="#ac902719f6e9691e42d39f5228e2cfaee">More...</a><br/></td></tr>
<tr class="separator:ac902719f6e9691e42d39f5228e2cfaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65e411e3e54c3b811be08af4f32c004"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#ac65e411e3e54c3b811be08af4f32c004">PktDesc_getNPlanes</a> (const <a class="el" href="structPktDesc.html">PktDesc</a> *pThis)</td></tr>
<tr class="memdesc:ac65e411e3e54c3b811be08af4f32c004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of planes in this type of packet.  <a href="#ac65e411e3e54c3b811be08af4f32c004">More...</a><br/></td></tr>
<tr class="separator:ac65e411e3e54c3b811be08af4f32c004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76f63b4e87557d37f5c2643bba21091"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#af76f63b4e87557d37f5c2643bba21091">PktDesc_getNPlanesOfType</a> (const <a class="el" href="structPktDesc.html">PktDesc</a> *pThis, <a class="el" href="plane_8h.html#a9a17cbe5723490ce1a58af37575a1689">plane_type_t</a> pt)</td></tr>
<tr class="memdesc:af76f63b4e87557d37f5c2643bba21091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of planes of a particular type in a packet.  <a href="#af76f63b4e87557d37f5c2643bba21091">More...</a><br/></td></tr>
<tr class="separator:af76f63b4e87557d37f5c2643bba21091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac955e1cd55e5d0fb76e8d30588ea75c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#ac955e1cd55e5d0fb76e8d30588ea75c9">PktDesc_addPlane</a> (<a class="el" href="structPktDesc.html">PktDesc</a> *pThis, <a class="el" href="structPlaneDesc.html">PlaneDesc</a> *pPlane)</td></tr>
<tr class="memdesc:ac955e1cd55e5d0fb76e8d30588ea75c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a plane to a packet.  <a href="#ac955e1cd55e5d0fb76e8d30588ea75c9">More...</a><br/></td></tr>
<tr class="separator:ac955e1cd55e5d0fb76e8d30588ea75c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77666e9de714a8fbf84a86461c0ea467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#a77666e9de714a8fbf84a86461c0ea467">PktDesc_copyPlanes</a> (<a class="el" href="structPktDesc.html">PktDesc</a> *pThis, const <a class="el" href="structPktDesc.html">PktDesc</a> *pOther)</td></tr>
<tr class="memdesc:a77666e9de714a8fbf84a86461c0ea467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy in all planes from another a packet descriptor.  <a href="#a77666e9de714a8fbf84a86461c0ea467">More...</a><br/></td></tr>
<tr class="separator:a77666e9de714a8fbf84a86461c0ea467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce751809f572e5a5481065aa7cb485e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#a7ce751809f572e5a5481065aa7cb485e">PktDesc_validate</a> (<a class="el" href="structPktDesc.html">PktDesc</a> *pThis)</td></tr>
<tr class="memdesc:a7ce751809f572e5a5481065aa7cb485e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if a legal plane layout is present.  <a href="#a7ce751809f572e5a5481065aa7cb485e">More...</a><br/></td></tr>
<tr class="separator:a7ce751809f572e5a5481065aa7cb485e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e08ab11ce73e87ddc549e47aaee520a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="plane_8h.html#a9a17cbe5723490ce1a58af37575a1689">plane_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#a1e08ab11ce73e87ddc549e47aaee520a">PktDesc_getPlaneType</a> (const <a class="el" href="structPktDesc.html">PktDesc</a> *pThis, int iPlane)</td></tr>
<tr class="memdesc:a1e08ab11ce73e87ddc549e47aaee520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the type of plane by index.  <a href="#a1e08ab11ce73e87ddc549e47aaee520a">More...</a><br/></td></tr>
<tr class="separator:a1e08ab11ce73e87ddc549e47aaee520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3f09495626acd68ac857b3d36fd314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPlaneDesc.html">PlaneDesc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#a8d3f09495626acd68ac857b3d36fd314">PktDesc_getPlane</a> (<a class="el" href="structPktDesc.html">PktDesc</a> *pThis, int iplane)</td></tr>
<tr class="memdesc:a8d3f09495626acd68ac857b3d36fd314"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the PlaneDescriptor for plane number <em>iplane</em> This can be used to query properties of the plane, such as units and the name.  <a href="#a8d3f09495626acd68ac857b3d36fd314">More...</a><br/></td></tr>
<tr class="separator:a8d3f09495626acd68ac857b3d36fd314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af27f253d3518398b734d8c62b51ef3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#a5af27f253d3518398b734d8c62b51ef3">PktDesc_getPlaneIdxByType</a> (const <a class="el" href="structPktDesc.html">PktDesc</a> *pThis, <a class="el" href="plane_8h.html#a9a17cbe5723490ce1a58af37575a1689">plane_type_t</a> ptype, int iRelIndex)</td></tr>
<tr class="memdesc:a5af27f253d3518398b734d8c62b51ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Nth plane of a given type.  <a href="#a5af27f253d3518398b734d8c62b51ef3">More...</a><br/></td></tr>
<tr class="separator:a5af27f253d3518398b734d8c62b51ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45f076657e8d4f04419280210948331"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#ae45f076657e8d4f04419280210948331">PktDesc_getPlaneIdxByName</a> (<a class="el" href="structPktDesc.html">PktDesc</a> *pThis, const char *name, <a class="el" href="plane_8h.html#a9a17cbe5723490ce1a58af37575a1689">plane_type_t</a> planeType)</td></tr>
<tr class="memdesc:ae45f076657e8d4f04419280210948331"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the plane number for the named plane.  <a href="#ae45f076657e8d4f04419280210948331">More...</a><br/></td></tr>
<tr class="separator:ae45f076657e8d4f04419280210948331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e289f62a6a49e10c8a26625f16b409"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1e289f62a6a49e10c8a26625f16b409"></a>
<a class="el" href="structPlaneDesc.html">PlaneDesc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#af1e289f62a6a49e10c8a26625f16b409">PktDesc_getXPlane</a> (<a class="el" href="structPktDesc.html">PktDesc</a> *pThis)</td></tr>
<tr class="memdesc:af1e289f62a6a49e10c8a26625f16b409"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the PlaneDescriptor for the 1st X Tag plane. <br/></td></tr>
<tr class="separator:af1e289f62a6a49e10c8a26625f16b409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb04363c672182f1365e6996c618b08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#a0eb04363c672182f1365e6996c618b08">PktDesc_encode</a> (const <a class="el" href="structPktDesc.html">PktDesc</a> *pThis, <a class="el" href="structDasBuf.html">DasBuf</a> *pBuf)</td></tr>
<tr class="memdesc:a0eb04363c672182f1365e6996c618b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a packet descriptor as XML data.  <a href="#a0eb04363c672182f1365e6996c618b08">More...</a><br/></td></tr>
<tr class="separator:a0eb04363c672182f1365e6996c618b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92769bff772270d88e8ef5806cd96751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#a92769bff772270d88e8ef5806cd96751">PktDesc_encodeData</a> (const <a class="el" href="structPktDesc.html">PktDesc</a> *pThis, <a class="el" href="structDasBuf.html">DasBuf</a> *pBuf)</td></tr>
<tr class="memdesc:a92769bff772270d88e8ef5806cd96751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a packet's current data In addition to holding the format information for Das2 Stream packets <a class="el" href="structPktDesc.html" title="Holds information for a single packet type in a Das2 stream. ">PktDesc</a> objects also hold a a single packet's worth of data.  <a href="#a92769bff772270d88e8ef5806cd96751">More...</a><br/></td></tr>
<tr class="separator:a92769bff772270d88e8ef5806cd96751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2133a1c6cc1d950cf7d28165b0f0d734"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#a2133a1c6cc1d950cf7d28165b0f0d734">PktDesc_decodeData</a> (<a class="el" href="structPktDesc.html">PktDesc</a> *pThis, <a class="el" href="structDasBuf.html">DasBuf</a> *pBuf)</td></tr>
<tr class="memdesc:a2133a1c6cc1d950cf7d28165b0f0d734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode 1 packet's worth of data from a buffer.  <a href="#a2133a1c6cc1d950cf7d28165b0f0d734">More...</a><br/></td></tr>
<tr class="separator:a2133a1c6cc1d950cf7d28165b0f0d734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6123ca370bbeb40ce3a51d4be36528dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#a6123ca370bbeb40ce3a51d4be36528dc">PktDesc_setValue</a> (<a class="el" href="structPktDesc.html">PktDesc</a> *pThis, size_t uPlane, size_t uItem, double val)</td></tr>
<tr class="memdesc:a6123ca370bbeb40ce3a51d4be36528dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for setting a single value in a plane This is just a shortcut for:  <a href="#a6123ca370bbeb40ce3a51d4be36528dc">More...</a><br/></td></tr>
<tr class="separator:a6123ca370bbeb40ce3a51d4be36528dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339a8403eee56b7114fb869241987272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#a339a8403eee56b7114fb869241987272">PktDesc_setValues</a> (<a class="el" href="structPktDesc.html">PktDesc</a> *pThis, size_t uPlane, const double *pVals)</td></tr>
<tr class="memdesc:a339a8403eee56b7114fb869241987272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for setting an array of values in a plane This is just a shortcut for:  <a href="#a339a8403eee56b7114fb869241987272">More...</a><br/></td></tr>
<tr class="separator:a339a8403eee56b7114fb869241987272"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:afcecb2add875c6162c0c6874d2c50faa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPktDesc.html#afcecb2add875c6162c0c6874d2c50faa">pUser</a></td></tr>
<tr class="memdesc:afcecb2add875c6162c0c6874d2c50faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">User data pointer.  <a href="#afcecb2add875c6162c0c6874d2c50faa">More...</a><br/></td></tr>
<tr class="separator:afcecb2add875c6162c0c6874d2c50faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Descriptor Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpfe6874699e74c021e04dfb9683fd7882"></a>These work for any type of Descriptor, including <a class="el" href="structPlaneDesc.html" title="Describes a data plane within a packet type. ">PlaneDesc</a> , <a class="el" href="structPktDesc.html" title="Holds information for a single packet type in a Das2 stream. ">PktDesc</a>, <a class="el" href="structStreamDesc.html" title="Describes the stream itself, in particular the compression used, current packetDescriptors, etc. ">StreamDesc</a>, <a class="el" href="structDasDs.html" title="Das2 Datasets. ">DasDs</a> and <a class="el" href="structDasVar.html" title="Das2 fexible variables. ">DasVar</a>.</p>
<p>To make your compiler happy you will need to cast Plane, Packet and Stream Descriptor pointers to just the generic type of Descriptor pointer when using these functions. For example: </p>
<div class="fragment"><div class="line">* <a class="code" href="structPktDesc.html">PktDesc</a>* pPktDesc;</div>
<div class="line">* hasProperty((Descriptor*)pPktDesc, <span class="stringliteral">&quot;SomePropName&quot;</span>);</div>
<div class="line">* </div>
</div><!-- fragment --><p>  <a class="el" href="structDasDesc.html" title="Base structure for Stream Header Items. ">DasDesc</a> </p>
</td></tr>
<tr class="memitem:ae2ab51bfe6c3a6147cf479bea57ce6e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#ae2ab51bfe6c3a6147cf479bea57ce6e7">DasDesc_equals</a> (const <a class="el" href="structDasDesc.html">DasDesc</a> *pOne, const <a class="el" href="structDasDesc.html">DasDesc</a> *pTwo)</td></tr>
<tr class="memdesc:ae2ab51bfe6c3a6147cf479bea57ce6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if two descriptors contain the same properties Note, the order of the properties may be different between the descriptors but if the contents are the same then the descriptors are considered to be equal.  <a href="#ae2ab51bfe6c3a6147cf479bea57ce6e7">More...</a><br/></td></tr>
<tr class="separator:ae2ab51bfe6c3a6147cf479bea57ce6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f30482a3f82abb5b3af822913304c1d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a0f30482a3f82abb5b3af822913304c1d">DasDesc_parent</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis)</td></tr>
<tr class="memdesc:a0f30482a3f82abb5b3af822913304c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The the parent of a Descriptor.  <a href="#a0f30482a3f82abb5b3af822913304c1d">More...</a><br/></td></tr>
<tr class="separator:a0f30482a3f82abb5b3af822913304c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45578a41142d8c07a67e494adef3916"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#ae45578a41142d8c07a67e494adef3916">DasDesc_length</a> (const <a class="el" href="structDasDesc.html">DasDesc</a> *pThis)</td></tr>
<tr class="memdesc:ae45578a41142d8c07a67e494adef3916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of properties in a descriptor.  <a href="#ae45578a41142d8c07a67e494adef3916">More...</a><br/></td></tr>
<tr class="separator:ae45578a41142d8c07a67e494adef3916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dd502c19f53d4555e35dd1e2561cc2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#ab5dd502c19f53d4555e35dd1e2561cc2">DasDesc_getNameByIdx</a> (const <a class="el" href="structDasDesc.html">DasDesc</a> *pThis, size_t uIdx)</td></tr>
<tr class="memdesc:ab5dd502c19f53d4555e35dd1e2561cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a property name by an index.  <a href="#ab5dd502c19f53d4555e35dd1e2561cc2">More...</a><br/></td></tr>
<tr class="separator:ab5dd502c19f53d4555e35dd1e2561cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e4b6c00c09044a0d041b7b2b41c50a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a71e4b6c00c09044a0d041b7b2b41c50a">DasDesc_getValByIdx</a> (const <a class="el" href="structDasDesc.html">DasDesc</a> *pThis, size_t uIdx)</td></tr>
<tr class="memdesc:a71e4b6c00c09044a0d041b7b2b41c50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a property value by an index.  <a href="#a71e4b6c00c09044a0d041b7b2b41c50a">More...</a><br/></td></tr>
<tr class="separator:a71e4b6c00c09044a0d041b7b2b41c50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4230394680b99d6e172920ef385ffafb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4230394680b99d6e172920ef385ffafb"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a4230394680b99d6e172920ef385ffafb">DasDesc_getTypeByIdx</a> (const <a class="el" href="structDasDesc.html">DasDesc</a> *pThis, size_t uIdx)</td></tr>
<tr class="memdesc:a4230394680b99d6e172920ef385ffafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a data type of a property by an index. <br/></td></tr>
<tr class="separator:a4230394680b99d6e172920ef385ffafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31eedc09f27f130c890f791f424a942"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#ae31eedc09f27f130c890f791f424a942">DasDesc_has</a> (const <a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *propertyName)</td></tr>
<tr class="memdesc:ae31eedc09f27f130c890f791f424a942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a property is present in a Descriptor or it's ancestors.  <a href="#ae31eedc09f27f130c890f791f424a942">More...</a><br/></td></tr>
<tr class="separator:ae31eedc09f27f130c890f791f424a942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f4b83038b5525a25d3b27f0f04fa19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a35f4b83038b5525a25d3b27f0f04fa19">DasDesc_set</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *sType, const char *sName, const char *sVal)</td></tr>
<tr class="memdesc:a35f4b83038b5525a25d3b27f0f04fa19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic property setter.  <a href="#a35f4b83038b5525a25d3b27f0f04fa19">More...</a><br/></td></tr>
<tr class="separator:a35f4b83038b5525a25d3b27f0f04fa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc0b413e9e8b13f25e830da74b62057"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a2cc0b413e9e8b13f25e830da74b62057">DasDesc_remove</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *propretyName)</td></tr>
<tr class="memdesc:a2cc0b413e9e8b13f25e830da74b62057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a property from a descriptor, if preset.  <a href="#a2cc0b413e9e8b13f25e830da74b62057">More...</a><br/></td></tr>
<tr class="separator:a2cc0b413e9e8b13f25e830da74b62057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6c5bbd5ce2cd9f2403ab31957e41fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b6c5bbd5ce2cd9f2403ab31957e41fd"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a8b6c5bbd5ce2cd9f2403ab31957e41fd">DasDesc_getStr</a> (const <a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *propertyName)</td></tr>
<tr class="memdesc:a8b6c5bbd5ce2cd9f2403ab31957e41fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the property of type String named propertyName. <br/></td></tr>
<tr class="separator:a8b6c5bbd5ce2cd9f2403ab31957e41fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62247ae94a1325baa95ebe9e746b7f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#af62247ae94a1325baa95ebe9e746b7f0">DasDesc_setStr</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *sName, const char *sVal)</td></tr>
<tr class="memdesc:af62247ae94a1325baa95ebe9e746b7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SetProperty methods add properties to any Descriptor (stream,packet,plane).  <a href="#af62247ae94a1325baa95ebe9e746b7f0">More...</a><br/></td></tr>
<tr class="separator:af62247ae94a1325baa95ebe9e746b7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4591a0a5eb8e51ef16967f1d590cb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d4591a0a5eb8e51ef16967f1d590cb4"></a>
<a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a5d4591a0a5eb8e51ef16967f1d590cb4">DasDesc_vSetStr</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *sName, const char *sFmt,...)</td></tr>
<tr class="memdesc:a5d4591a0a5eb8e51ef16967f1d590cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a string property in the manner of sprintf. <br/></td></tr>
<tr class="separator:a5d4591a0a5eb8e51ef16967f1d590cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e51bf49cc74d47e4688ff539415b10d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a7e51bf49cc74d47e4688ff539415b10d">DasDesc_getDouble</a> (const <a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *propertyName)</td></tr>
<tr class="memdesc:a7e51bf49cc74d47e4688ff539415b10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the property of type double named propertyName.  <a href="#a7e51bf49cc74d47e4688ff539415b10d">More...</a><br/></td></tr>
<tr class="separator:a7e51bf49cc74d47e4688ff539415b10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b8f1cd04902a9479889053c6317d6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21b8f1cd04902a9479889053c6317d6f"></a>
<a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a21b8f1cd04902a9479889053c6317d6f">DasDesc_setDouble</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *propertyName, double value)</td></tr>
<tr class="memdesc:a21b8f1cd04902a9479889053c6317d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set property of type double. <br/></td></tr>
<tr class="separator:a21b8f1cd04902a9479889053c6317d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b0702db716affb564744ccc079abdb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#ac7b0702db716affb564744ccc079abdb">DasDesc_getDatum</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *sPropName, <a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a> units)</td></tr>
<tr class="memdesc:ac7b0702db716affb564744ccc079abdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the a numeric property in the specified units.  <a href="#ac7b0702db716affb564744ccc079abdb">More...</a><br/></td></tr>
<tr class="separator:ac7b0702db716affb564744ccc079abdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8174b65c398388321a39a2c345fe50a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#ab8174b65c398388321a39a2c345fe50a">DasDesc_setDatum</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *sName, double rVal, <a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a> units)</td></tr>
<tr class="memdesc:ab8174b65c398388321a39a2c345fe50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set property of type Datum (double, UnitType pair)  <a href="#ab8174b65c398388321a39a2c345fe50a">More...</a><br/></td></tr>
<tr class="separator:ab8174b65c398388321a39a2c345fe50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465e5713cb5cc25e1b2f491bcc5329f2"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a465e5713cb5cc25e1b2f491bcc5329f2">DasDesc_getDoubleAry</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *propertyName, int *nitems)</td></tr>
<tr class="memdesc:a465e5713cb5cc25e1b2f491bcc5329f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values of an array property.  <a href="#a465e5713cb5cc25e1b2f491bcc5329f2">More...</a><br/></td></tr>
<tr class="separator:a465e5713cb5cc25e1b2f491bcc5329f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38c9ac735d25ccc3badd7517fbe173a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa38c9ac735d25ccc3badd7517fbe173a"></a>
<a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#aa38c9ac735d25ccc3badd7517fbe173a">DasDesc_setDoubleArray</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *propertyName, int nitems, double *value)</td></tr>
<tr class="memdesc:aa38c9ac735d25ccc3badd7517fbe173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the property of type double array. <br/></td></tr>
<tr class="separator:aa38c9ac735d25ccc3badd7517fbe173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae82535e9f6ec0e968a4c6188340496"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a2ae82535e9f6ec0e968a4c6188340496">DasDesc_getInt</a> (const <a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *propertyName)</td></tr>
<tr class="memdesc:a2ae82535e9f6ec0e968a4c6188340496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a property integer value.  <a href="#a2ae82535e9f6ec0e968a4c6188340496">More...</a><br/></td></tr>
<tr class="separator:a2ae82535e9f6ec0e968a4c6188340496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad521f9fa550d4df41786869901432e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad521f9fa550d4df41786869901432e8"></a>
<a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#aad521f9fa550d4df41786869901432e8">DasDesc_setInt</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *sName, int nVal)</td></tr>
<tr class="memdesc:aad521f9fa550d4df41786869901432e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the property of type int. <br/></td></tr>
<tr class="separator:aad521f9fa550d4df41786869901432e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769684d411762127bcca8abc41320658"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a769684d411762127bcca8abc41320658">DasDesc_getBool</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *sPropName)</td></tr>
<tr class="memdesc:a769684d411762127bcca8abc41320658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a property boolean value.  <a href="#a769684d411762127bcca8abc41320658">More...</a><br/></td></tr>
<tr class="separator:a769684d411762127bcca8abc41320658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9426a9631dbf304a8b65523781f9b16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9426a9631dbf304a8b65523781f9b16"></a>
<a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#ad9426a9631dbf304a8b65523781f9b16">DasDesc_setDatumRng</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *sName, double beg, double end, <a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a> units)</td></tr>
<tr class="memdesc:ad9426a9631dbf304a8b65523781f9b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set property of type DatumRange (double, double, UnitType triple) <br/></td></tr>
<tr class="separator:ad9426a9631dbf304a8b65523781f9b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d697e53b21d42dd1e1a5b5187758aea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a1d697e53b21d42dd1e1a5b5187758aea">DasDesc_getStrRng</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *sName, char *sMin, char *sMax, <a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a> *pUnits, size_t uLen)</td></tr>
<tr class="memdesc:a1d697e53b21d42dd1e1a5b5187758aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a property of type DatumRange with unconverted strings.  <a href="#a1d697e53b21d42dd1e1a5b5187758aea">More...</a><br/></td></tr>
<tr class="separator:a1d697e53b21d42dd1e1a5b5187758aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936f922d2581678c393e1ae3a9f4630f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a936f922d2581678c393e1ae3a9f4630f">DasDesc_setFloatAry</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const char *propertyName, int nitems, float *value)</td></tr>
<tr class="memdesc:a936f922d2581678c393e1ae3a9f4630f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the property of type float array.  <a href="#a936f922d2581678c393e1ae3a9f4630f">More...</a><br/></td></tr>
<tr class="separator:a936f922d2581678c393e1ae3a9f4630f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031c1cd3700d9707801208fd1fc482b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a031c1cd3700d9707801208fd1fc482b7">DasDesc_copyIn</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, const <a class="el" href="structDasDesc.html">DasDesc</a> *source)</td></tr>
<tr class="memdesc:a031c1cd3700d9707801208fd1fc482b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deepcopy properties into a descriptor.  <a href="#a031c1cd3700d9707801208fd1fc482b7">More...</a><br/></td></tr>
<tr class="separator:a031c1cd3700d9707801208fd1fc482b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354146201493b2e11aa8cd5cb7b83731"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasDesc.html#a354146201493b2e11aa8cd5cb7b83731">DasDesc_encode</a> (<a class="el" href="structDasDesc.html">DasDesc</a> *pThis, <a class="el" href="structDasBuf.html">DasBuf</a> *pBuf, const char *sIndent)</td></tr>
<tr class="memdesc:a354146201493b2e11aa8cd5cb7b83731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a generic set of properties to a buffer.  <a href="#a354146201493b2e11aa8cd5cb7b83731">More...</a><br/></td></tr>
<tr class="separator:a354146201493b2e11aa8cd5cb7b83731"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adfcda4585cee753e26aa1ffdef8baa11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPktDesc.html">PktDesc</a> * new_PktDesc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a packet descriptor with the default settings. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <a class="el" href="structPktDesc.html" title="Holds information for a single packet type in a Das2 stream. ">PktDesc</a> allocated on the heap, or NULL on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9911a5e0b54dedcc9996439be05c581"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPktDesc.html">PktDesc</a> * new_PktDesc_xml </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasBuf.html">DasBuf</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPktId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structPktDesc.html" title="Holds information for a single packet type in a Das2 stream. ">PktDesc</a> from XML data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>The buffer to read. Reading will start with the read point and will run until DasBuf_remaining() is 0 or the end tag is found, which ever comes first. </td></tr>
    <tr><td class="paramname">pParent</td><td>The parent packet descriptor, this may be NULL </td></tr>
    <tr><td class="paramname">nPktId</td><td>The packet's ID within it's parent's array. May be 0 if and only if the pParent is NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <a class="el" href="structPktDesc.html" title="Holds information for a single packet type in a Das2 stream. ">PktDesc</a> allocated on the heap, or NULL on an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a29fa1d69eec2a96208f5ba2179adb9c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PktDesc_getId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the packet ID for this packet. </p>
<p>Each packet type within a Das 2 Stream has a unique ID form 1 to 99 inclusive. Note that ID's <b>can be reused</b>! So processing code must be on the lookout for re-definition packets. </p>
<dl class="section return"><dt>Returns</dt><dd>the packet id, a number between 1 and 99 or -1 if there is on packet id assigned. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2a7e1d9918238ef952c149031c56e48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * PktDesc_getGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data group for this packet. </p>
<p>Packets with the same group should be able to be plotted on the same graph. This is the same as a join in QDataset terms</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to a packet desciptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the packet has no specified group, or the group string which follows the rules for valid identifers in <a class="el" href="group__utilities.html#ga55d67cc25ba9535f4c03568ae12d9e65" title="Check that a string is suitable for use as an object ID. ">das_assert_valid_id()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa7ca8db95981359db19c479260ab8712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PktDesc_setGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the data group for this packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to a packet descriptor structure </td></tr>
    <tr><td class="paramname">sGroup</td><td>The new group name which must be a valid id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac902719f6e9691e42d39f5228e2cfaee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t PktDesc_recBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of data records defined by a packet descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The packet descriptor to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of a single packet's worth of data. </dd></dl>

</div>
</div>
<a class="anchor" id="ac65e411e3e54c3b811be08af4f32c004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t PktDesc_getNPlanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of planes in this type of packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>the packet descriptor in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of planes defined in this packet. </dd></dl>

</div>
</div>
<a class="anchor" id="af76f63b4e87557d37f5c2643bba21091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t PktDesc_getNPlanesOfType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plane_8h.html#a9a17cbe5723490ce1a58af37575a1689">plane_type_t</a>&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of planes of a particular type in a packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The packet descriptor to check </td></tr>
    <tr><td class="paramname">pt</td><td>the plane type to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of planes of a particular type in this packet descriptor </dd></dl>

</div>
</div>
<a class="anchor" id="ac955e1cd55e5d0fb76e8d30588ea75c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PktDesc_addPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPlaneDesc.html">PlaneDesc</a> *&#160;</td>
          <td class="paramname"><em>pPlane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a plane to a packet. </p>
<p>All data in a das2 stream are sent via packets, each packet type has 1-100 planes. A plane can be a single column of numbers, which has one value per data packet, or in the case of &lt;yscan&gt; planes they can be more like sub-tables which have many values per packet. The newly added plane will have this <a class="el" href="structPktDesc.html" title="Holds information for a single packet type in a Das2 stream. ">PktDesc</a> assigned as it's parent.</p>
<p>Planes have types. A Packet must have at least 1 &lt;x&gt; plane. In general it may have as many &lt;y&gt; &lt;yscan&gt; planes as it likes up to the plane limit. For packets with &lt;z&gt; planes, no &lt;yscan&gt; planes are allowed and one and only one &lt;y&gt; plane must be preset. This function enforces the packet formation rules. In summary the following patterns are legal.</p>
<ul>
<li>X [X]</li>
<li>X [X] Y [Y Y ...]</li>
<li>X [X] YScan [YScan YScan ...]</li>
<li>X [X] Y [Y Y ...] YScan [YScan YScan ...] (see note)</li>
<li>X [X] Z [Z Z ...]</li>
</ul>
<p>where [] indicates optional planes. Note: Y and YScan planes can be interleaved in any order.</p>
<p>This function adds the plane after all existing planes. Thus the index of any existing planes is not altered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The packet descriptor to receive the new plane definition </td></tr>
    <tr><td class="paramname">pPlane</td><td>The plane to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success the index of the new plane is returned, or -1 on an error </dd></dl>

</div>
</div>
<a class="anchor" id="a77666e9de714a8fbf84a86461c0ea467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a> PktDesc_copyPlanes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy in all planes from another a packet descriptor. </p>
<p>Deepcopy's the plane descriptors in pOther and attaches the newly allocated planes to this <a class="el" href="structPktDesc.html" title="Holds information for a single packet type in a Das2 stream. ">PktDesc</a> object. This packet descriptor must not already have any planes defined or this function will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>the destination for the newly allocated PlaneDescriptors </td></tr>
    <tr><td class="paramname">pOther</td><td>the source of the PlaneDescriptors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a positive error number if there is a problem </dd></dl>

</div>
</div>
<a class="anchor" id="a7ce751809f572e5a5481065aa7cb485e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PktDesc_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if a legal plane layout is present. </p>
<p>Since not all checks for a legal packet layout can be made while the sub-objects are being added to the packet descriptor, this function is provided to check the layout after adding all planes to a packet.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structPktDesc.html#ac955e1cd55e5d0fb76e8d30588ea75c9" title="Add a plane to a packet. ">PktDesc_addPlane()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The packet descriptor to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this packet descriptor has a legal set of planes, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e08ab11ce73e87ddc549e47aaee520a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="plane_8h.html#a9a17cbe5723490ce1a58af37575a1689">plane_type_t</a> PktDesc_getPlaneType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iPlane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the type of plane by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>the packet descriptor to query </td></tr>
    <tr><td class="paramname">iPlane</td><td>the index in question. Valid values for this parameter are 0 to MAXPLANES - 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the index corresponds to a data plane, then one of the enum values is return: <ul>
<li>
X </li>
<li>
Y </li>
<li>
YSCAN </li>
<li>
Z</li>
</ul>
is returned, otherwise: <ul>
<li>
Invalid</li>
</ul>
is returned </dd></dl>

</div>
</div>
<a class="anchor" id="a8d3f09495626acd68ac857b3d36fd314"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPlaneDesc.html">PlaneDesc</a> * PktDesc_getPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iplane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the PlaneDescriptor for plane number <em>iplane</em> This can be used to query properties of the plane, such as units and the name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The packet descriptor to query </td></tr>
    <tr><td class="paramname">iplane</td><td>The index of the plane to retrieve. The 0th plane is an &lt;x&gt; plane if one is present in the stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5af27f253d3518398b734d8c62b51ef3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PktDesc_getPlaneIdxByType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plane_8h.html#a9a17cbe5723490ce1a58af37575a1689">plane_type_t</a>&#160;</td>
          <td class="paramname"><em>ptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iRelIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Nth plane of a given type. </p>
<p>This is useful for iterating over all planes of a given type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A packet descriptor structure pointer.</td></tr>
    <tr><td class="paramname">ptype</td><td>The plane type, one X, Y, Z, YScan</td></tr>
    <tr><td class="paramname">iRelIndex</td><td>The number of the plane of a given type to find. The lowest index will be 0 for a given type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute plane index for the Nth plane of a given type. If No planes of the given type are present, or iIndex is out of range -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ae45f076657e8d4f04419280210948331"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PktDesc_getPlaneIdxByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plane_8h.html#a9a17cbe5723490ce1a58af37575a1689">plane_type_t</a>&#160;</td>
          <td class="paramname"><em>planeType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the plane number for the named plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The packet descriptor to query. </td></tr>
    <tr><td class="paramname">name</td><td>The name in of the plane to find </td></tr>
    <tr><td class="paramname">planeType</td><td>if not set to 0, then PlaneType must also match. Note that typically the 0th plane is typically the &lt;x&gt; plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0eb04363c672182f1365e6996c618b08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a> PktDesc_encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDasBuf.html">DasBuf</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a packet descriptor as XML data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The packet descriptor to store as string data </td></tr>
    <tr><td class="paramname">pBuf</td><td>A buffer object to received the string data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or a positive integer if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a92769bff772270d88e8ef5806cd96751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a> PktDesc_encodeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDasBuf.html">DasBuf</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a packet's current data In addition to holding the format information for Das2 Stream packets <a class="el" href="structPktDesc.html" title="Holds information for a single packet type in a Das2 stream. ">PktDesc</a> objects also hold a a single packet's worth of data. </p>
<p>Use this function to encode the current data values for output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The packet descriptor that has been loaded with data </td></tr>
    <tr><td class="paramname">pBuf</td><td>A buffer to receive the encoded bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or a positive integer if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a2133a1c6cc1d950cf7d28165b0f0d734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a> PktDesc_decodeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDasBuf.html">DasBuf</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode 1 packet's worth of data from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>the packet descriptor to handle decoding </td></tr>
    <tr><td class="paramname">pBuf</td><td>The buffer with the data, data will be read from the current read point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or a positive integer if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a6123ca370bbeb40ce3a51d4be36528dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a> PktDesc_setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uItem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for setting a single value in a plane This is just a shortcut for: </p>
<div class="fragment"><div class="line">* <a class="code" href="structPlaneDesc.html">PlaneDesc</a>* pPlane = <a class="code" href="structPktDesc.html#a8d3f09495626acd68ac857b3d36fd314">PktDesc_getPlane</a>(pPkt, uPlane);</div>
<div class="line">* PlaneDesc_setValue(pPlane, uItem, value);</div>
<div class="line">* </div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The packet descriptor in question. </td></tr>
    <tr><td class="paramname">uPlane</td><td>The index of the plane to receive the values </td></tr>
    <tr><td class="paramname">uItem</td><td>The index of the item in the plane to be set to the new value </td></tr>
    <tr><td class="paramname">val</td><td>The new value for this item in this plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a positive error code if there is a problem </dd></dl>

</div>
</div>
<a class="anchor" id="a339a8403eee56b7114fb869241987272"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a> PktDesc_setValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPktDesc.html">PktDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for setting an array of values in a plane This is just a shortcut for: </p>
<div class="fragment"><div class="line">* <a class="code" href="structPlaneDesc.html">PlaneDesc</a>* pPlane = <a class="code" href="structPktDesc.html#a8d3f09495626acd68ac857b3d36fd314">PktDesc_getPlane</a>(pPkt, uPlane);</div>
<div class="line">* PlaneDesc_setValues(pPlane, pVals);</div>
<div class="line">* </div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The packet descriptor in question. </td></tr>
    <tr><td class="paramname">uPlane</td><td>The index of the plane to receive the values </td></tr>
    <tr><td class="paramname">pVals</td><td>The array of values to set. The array is assumed to be the same length as the number of items in plane <em>uPlane</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a positive error code if there is a problem </dd></dl>

</div>
</div>
<a class="anchor" id="ae2ab51bfe6c3a6147cf479bea57ce6e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DasDesc_equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pTwo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check to see if two descriptors contain the same properties Note, the order of the properties may be different between the descriptors but if the contents are the same then the descriptors are considered to be equal. </p>
<p>Note that parent descriptor properties are not checked when handling the comparison. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>maybe check parents too.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pOne</td><td>The first descriptor </td></tr>
    <tr><td class="paramname">pTwo</td><td>The second descriptor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f30482a3f82abb5b3af822913304c1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structDasDesc.html">DasDesc</a> * DasDesc_parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The the parent of a Descriptor. </p>
<p>Plane descriptors are owned by packet descriptors and packet descriptors are owned by stream descriptors. This function lets you craw the ownership hierarchy</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The owner of a descriptor, or NULL if this is a top level descriptor, (i.e. a Stream Descriptor) </dd></dl>

</div>
</div>
<a class="anchor" id="ae45578a41142d8c07a67e494adef3916"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t DasDesc_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of properties in a descriptor. </p>
<p>Descriptor's have a hierarchy. In general when a property is requested, if a given Descriptor does not have a property the request is passed to the parent descriptor. This function <b>only</b> returns the number of properties in the given descriptor. It does not include properties owned by parents or ancestors.</p>
<p>This is useful when iterating over all properties in a descriptor. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDasDesc.html#ab5dd502c19f53d4555e35dd1e2561cc2" title="Get a property name by an index. ">DasDesc_getNameByIdx()</a> </dd>
<dd>
<a class="el" href="structDasDesc.html#a71e4b6c00c09044a0d041b7b2b41c50a" title="Get a property value by an index. ">DasDesc_getValByIdx()</a> </dd>
<dd>
<a class="el" href="structDasDesc.html#a4230394680b99d6e172920ef385ffafb" title="Get a data type of a property by an index. ">DasDesc_getTypeByIdx()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to the descriptor to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of properties in this, and only this, descriptor. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5dd502c19f53d4555e35dd1e2561cc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * DasDesc_getNameByIdx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a property name by an index. </p>
<p>This is useful when iterating over all properties in a Descriptor. Only properties owed by a descriptor are queried in this manner. Parent descriptors are not consulted.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDasDesc.html#ae45578a41142d8c07a67e494adef3916" title="Get the number of properties in a descriptor. ">DasDesc_length()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to the descriptor to query </td></tr>
    <tr><td class="paramname">uIdx</td><td>The index of the property, will be a value between 0 and the return value from Desc_getNProps() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer the requested property name or NULL if there is no property at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a71e4b6c00c09044a0d041b7b2b41c50a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * DasDesc_getValByIdx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a property value by an index. </p>
<p>This is useful when iterating over all properties in a Descriptor. Only properties owned by a descriptor are queried in this manner. Parent descriptors are not consulted.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDasDesc.html#ae45578a41142d8c07a67e494adef3916" title="Get the number of properties in a descriptor. ">DasDesc_length()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>A pointer to the descriptor to query </td></tr>
    <tr><td class="paramname">uIdx</td><td>The number of the property, will be a value from 0 and 1 less than the return value from Desc_getNProps() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer the requested property value or NULL if there is no property at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="ae31eedc09f27f130c890f791f424a942"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DasDesc_has </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propertyName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a property is present in a Descriptor or it's ancestors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>the descriptor object to query </td></tr>
    <tr><td class="paramname">propertyName</td><td>the name of the property to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the descriptor or one of it's ancestors has a property with the given name, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a35f4b83038b5525a25d3b27f0f04fa19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a> DasDesc_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic property setter. </p>
<p>All properties are stored internally as strings. The various typed Desc_setProp* functions all call this function after converting their arguments to strings.</p>
<dl class="section warning"><dt>Warning</dt><dd>To insure that the string to type conversions are consistent it is strongly recommended that you use one of the typed functions instead of this generic version unless you have no choice.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The Descriptor to receive the property </td></tr>
    <tr><td class="paramname">sType</td><td>The Type of property should be one of the strings:<ul>
<li><b>boolean</b> </li>
<li><b>double</b> </li>
<li><b>doubleArray</b> </li>
<li><b>Datum</b> </li>
<li><b>DatumRange</b> </li>
<li><b>int</b> </li>
<li><b>String</b> </li>
<li><b>Time</b> </li>
<li><b>TimeRange</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">sName</td><td>The property name, which cannot contain spaces </td></tr>
    <tr><td class="paramname">sVal</td><td>The value, which may be anything including NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a positive error code if there is a problem. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cc0b413e9e8b13f25e830da74b62057"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DasDesc_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propretyName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a property from a descriptor, if preset. </p>
<p>It is safe to call this function for properties not present on the descriptor, it simply does nothing and returns false.</p>
<dl class="section return"><dt>Returns</dt><dd>false if the property wasn't present to begin with, true otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="af62247ae94a1325baa95ebe9e746b7f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a> DasDesc_setStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SetProperty methods add properties to any Descriptor (stream,packet,plane). </p>
<p>The typed methods (e.g. setPropertyDatum) property tag the property with a type so that it will be parsed into the given type. </p>

</div>
</div>
<a class="anchor" id="a7e51bf49cc74d47e4688ff539415b10d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double DasDesc_getDouble </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propertyName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the property of type double named propertyName. </p>
<p>The property value is parsed using sscanf. </p>

</div>
</div>
<a class="anchor" id="ac7b0702db716affb564744ccc079abdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double DasDesc_getDatum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sPropName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a>&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the a numeric property in the specified units. </p>
<p>Descriptor properties my be provided as Datums. Datums are a double value along with a specified measurement unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The Descriptor containing the property in question. </td></tr>
    <tr><td class="paramname">sPropName</td><td>The name of the property to retrieve. </td></tr>
    <tr><td class="paramname">units</td><td>The units of measure in which the return value will be represented. If the property value is stored in a different set of units than those indicated by this parameter than the output will be converted to the given unit type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted value or <b>DAS_FILL_VALUE</b> if conversion to the desired units is not possible. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8174b65c398388321a39a2c345fe50a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a> DasDesc_setDatum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a>&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set property of type Datum (double, UnitType pair) </p>
<p>If a property with this name already exists it is 1st deleted and then the new property is added in its place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The descriptor to receive the property </td></tr>
    <tr><td class="paramname">sName</td><td>The name of the property to set </td></tr>
    <tr><td class="paramname">rVal</td><td>The numeric value of the property </td></tr>
    <tr><td class="paramname">units</td><td>The units of measure for the property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a465e5713cb5cc25e1b2f491bcc5329f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double * DasDesc_getDoubleAry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nitems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the values of an array property. </p>
<p>Space for the array is allocated by getDoubleArrayFromString. and nitems is set to indicate the size of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pThis</td><td>the descriptor object to query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">propertyName</td><td>the name of the proprety to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nitems</td><td>a pointer to a an integer containing the number of values in the returned array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a double array allocated on the heap. It is the caller's responsibility to depose of the memory when it is no longer needed. If the named property doesn't exist the program exits.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>hasProperty() </dd></dl>

</div>
</div>
<a class="anchor" id="a2ae82535e9f6ec0e968a4c6188340496"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DasDesc_getInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propertyName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a property integer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>the descriptor object to query </td></tr>
    <tr><td class="paramname">propertyName</td><td>the name of the proprety to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the named property or exits the program if the named proprety doesn't exist in this descriptor.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>hasProperty() </dd></dl>

</div>
</div>
<a class="anchor" id="a769684d411762127bcca8abc41320658"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DasDesc_getBool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sPropName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a property boolean value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>the descriptor object to query </td></tr>
    <tr><td class="paramname">sPropName</td><td>the name of the proprety to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value is "true", or any positive integer, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d697e53b21d42dd1e1a5b5187758aea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a> DasDesc_getStrRng </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a> *&#160;</td>
          <td class="paramname"><em>pUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a property of type DatumRange with unconverted strings. </p>
<p>This version is handy if you just want to know the intrinsic units of the range without converting the values to some specific type of double value. </p>

</div>
</div>
<a class="anchor" id="a936f922d2581678c393e1ae3a9f4630f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a> DasDesc_setFloatAry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the property of type float array. </p>
<p>Note the array is cast to a double array before encoding. </p>

</div>
</div>
<a class="anchor" id="a031c1cd3700d9707801208fd1fc482b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DasDesc_copyIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deepcopy properties into a descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>the descriptor to receive a copy of the properties </td></tr>
    <tr><td class="paramname">source</td><td>the descriptor with the properties to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a354146201493b2e11aa8cd5cb7b83731"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a> DasDesc_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDasDesc.html">DasDesc</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDasBuf.html">DasBuf</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sIndent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode a generic set of properties to a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The descriptors who's properties should be encoded </td></tr>
    <tr><td class="paramname">pBuf</td><td>A buffer object to receive the XML data </td></tr>
    <tr><td class="paramname">sIndent</td><td>An indent level for the property strings, makes 'em look nice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation succeeded, a non-zero return code otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="afcecb2add875c6162c0c6874d2c50faa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pUser</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User data pointer. </p>
<p>The stream-&gt;packet-&gt;plane hierarchy provides a good organizational structure for application data, especially for applications whose purpose is to filter streams. This pointer can be used to hold a reference to information that is not serialized. It is initialized to NULL when a packet descriptor is created otherwise the library doesn't deal with it in any other way. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>das2/<a class="el" href="packet_8h_source.html">packet.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
