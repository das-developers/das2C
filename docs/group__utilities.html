<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libdas2: Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="das2logo-32.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">libdas2
   </div>
   <div id="projectbrief">das2 core C utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utilities</div>  </div>
</div><!--header-->
<div class="contents">

<p>Library initialization, error handling, loggging and a few minor libc extensions.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Library initialization, error handling, loggging and a few minor libc extensions. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDasBuf.html">DasBuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Little buffer class to handle accumulating string data.  <a href="structDasBuf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdas__error__msg.html">das_error_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure returned from <a class="el" href="group__utilities.html#ga6ba29a2c56bc94a222885261d9b5f464" title="Return the saved das2 error message buffer. ">das_get_error()</a>.  <a href="structdas__error__msg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga737ce744af9e674be856799643f33afb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga737ce744af9e674be856799643f33afb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga737ce744af9e674be856799643f33afb">daslog_trace</a>(M)&#160;&#160;&#160;daslog(DASLOG_TRACE, __FILE__, __LINE__, M)</td></tr>
<tr class="memdesc:ga737ce744af9e674be856799643f33afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro wrapper around das_log() for TRACE messages with out variable args. <br/></td></tr>
<tr class="separator:ga737ce744af9e674be856799643f33afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7505b2a679a61af5cce2e1c5cda53085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7505b2a679a61af5cce2e1c5cda53085"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7505b2a679a61af5cce2e1c5cda53085">daslog_debug</a>(M)&#160;&#160;&#160;daslog(DASLOG_DEBUG, __FILE__, __LINE__, M)</td></tr>
<tr class="memdesc:ga7505b2a679a61af5cce2e1c5cda53085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro wrapper around das_log() for DEBUG messages with out variable args. <br/></td></tr>
<tr class="separator:ga7505b2a679a61af5cce2e1c5cda53085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1186bf968091d6ab2155c2a06316be48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1186bf968091d6ab2155c2a06316be48"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1186bf968091d6ab2155c2a06316be48">daslog_info</a>(M)&#160;&#160;&#160;daslog(DASLOG_INFO, __FILE__, __LINE__, M)</td></tr>
<tr class="memdesc:ga1186bf968091d6ab2155c2a06316be48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro wrapper around das_log() for INFO messages with out variable args. <br/></td></tr>
<tr class="separator:ga1186bf968091d6ab2155c2a06316be48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b90d92afdc87233fb0e997b0877047"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga71b90d92afdc87233fb0e997b0877047"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga71b90d92afdc87233fb0e997b0877047">daslog_warn</a>(M)&#160;&#160;&#160;daslog(DASLOG_WARN, __FILE__, __LINE__, M)</td></tr>
<tr class="memdesc:ga71b90d92afdc87233fb0e997b0877047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro wrapper around das_log() for WARNING messages with out variable args. <br/></td></tr>
<tr class="separator:ga71b90d92afdc87233fb0e997b0877047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a17078df9f0fb96f51eb9742ef0533"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf5a17078df9f0fb96f51eb9742ef0533"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf5a17078df9f0fb96f51eb9742ef0533">daslog_error</a>(M)&#160;&#160;&#160;daslog(DASLOG_ERROR, __FILE__, __LINE__, M)</td></tr>
<tr class="memdesc:gaf5a17078df9f0fb96f51eb9742ef0533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro wrapper around das_log() for ERROR messages with out variable args. <br/></td></tr>
<tr class="separator:gaf5a17078df9f0fb96f51eb9742ef0533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac9b6656d0c70cc25291a1a407872306"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaac9b6656d0c70cc25291a1a407872306"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaac9b6656d0c70cc25291a1a407872306">daslog_critical</a>(M)&#160;&#160;&#160;daslog(DAS_LL_CRITICAL, __FILE__, __LINE__, M)</td></tr>
<tr class="memdesc:gaac9b6656d0c70cc25291a1a407872306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro wrapper around das_log() for CRITICAL messages with out variable args. <br/></td></tr>
<tr class="separator:gaac9b6656d0c70cc25291a1a407872306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga314855e6e1c430cf587daded204ed179"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga314855e6e1c430cf587daded204ed179"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga314855e6e1c430cf587daded204ed179">daslog_trace_v</a>(F,...)&#160;&#160;&#160;daslog(DASLOG_TRACE, __FILE__, __LINE__, F, __VA_ARGS__)</td></tr>
<tr class="memdesc:ga314855e6e1c430cf587daded204ed179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro wrapper around das_log() for TRACE messages with variable arguments. <br/></td></tr>
<tr class="separator:ga314855e6e1c430cf587daded204ed179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a34c24ab01ea0d82ee0f4ac03c99c6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a34c24ab01ea0d82ee0f4ac03c99c6f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5a34c24ab01ea0d82ee0f4ac03c99c6f">daslog_debug_v</a>(F,...)&#160;&#160;&#160;daslog(DASLOG_DEBUG, __FILE__, __LINE__, F, __VA_ARGS__)</td></tr>
<tr class="memdesc:ga5a34c24ab01ea0d82ee0f4ac03c99c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro wrapper around das_log() for DEBUG messages with variable arguments. <br/></td></tr>
<tr class="separator:ga5a34c24ab01ea0d82ee0f4ac03c99c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf1823c474467e892bbbcee5f6d0f48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabdf1823c474467e892bbbcee5f6d0f48"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabdf1823c474467e892bbbcee5f6d0f48">daslog_info_v</a>(F,...)&#160;&#160;&#160;daslog(DASLOG_INFO, __FILE__, __LINE__, F, __VA_ARGS__)</td></tr>
<tr class="memdesc:gabdf1823c474467e892bbbcee5f6d0f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro wrapper around das_log() for INFO messages with variable arguments. <br/></td></tr>
<tr class="separator:gabdf1823c474467e892bbbcee5f6d0f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe67a26eb7bc42428ceb81bbf769499f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabe67a26eb7bc42428ceb81bbf769499f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabe67a26eb7bc42428ceb81bbf769499f">daslog_warn_v</a>(F,...)&#160;&#160;&#160;daslog(DASLOG_WARN, __FILE__, __LINE__, F, __VA_ARGS__)</td></tr>
<tr class="memdesc:gabe67a26eb7bc42428ceb81bbf769499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro wrapper around das_log() for WARNING messages with variable arguments. <br/></td></tr>
<tr class="separator:gabe67a26eb7bc42428ceb81bbf769499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga472520f10bf2d7df865ffeed66f3f62a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga472520f10bf2d7df865ffeed66f3f62a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga472520f10bf2d7df865ffeed66f3f62a">daslog_error_v</a>(F,...)&#160;&#160;&#160;daslog(DASLOG_ERROR, __FILE__, __LINE__, F, __VA_ARGS__)</td></tr>
<tr class="memdesc:ga472520f10bf2d7df865ffeed66f3f62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro wrapper around das_log() for ERROR messages with variable arguments. <br/></td></tr>
<tr class="separator:ga472520f10bf2d7df865ffeed66f3f62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2291a5b141e4b7802147efb86c678dc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2291a5b141e4b7802147efb86c678dc3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2291a5b141e4b7802147efb86c678dc3">daslog_critical_v</a>(F,...)&#160;&#160;&#160;daslog(DASLOG_CRIT, __FILE__, __LINE__, F, __VA_ARGS__)</td></tr>
<tr class="memdesc:ga2291a5b141e4b7802147efb86c678dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro wrapper around das_log() for CRITICAL messages with variable arguments. <br/></td></tr>
<tr class="separator:ga2291a5b141e4b7802147efb86c678dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae810e1359ccac288465246ae377d9482"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae810e1359ccac288465246ae377d9482"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae810e1359ccac288465246ae377d9482">DAS_OKAY</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gae810e1359ccac288465246ae377d9482"><td class="mdescLeft">&#160;</td><td class="mdescRight">success return code <br/></td></tr>
<tr class="separator:gae810e1359ccac288465246ae377d9482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef9c28126d100b783969cb38705fe1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9ef9c28126d100b783969cb38705fe1c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9ef9c28126d100b783969cb38705fe1c">DASERR_DIS_EXIT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga9ef9c28126d100b783969cb38705fe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to indicate that errors should trigger program exit. <br/></td></tr>
<tr class="separator:ga9ef9c28126d100b783969cb38705fe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2e4971120478e0d74d5d7a2b23ee056"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad2e4971120478e0d74d5d7a2b23ee056"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad2e4971120478e0d74d5d7a2b23ee056">DASERR_DIS_RET</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gad2e4971120478e0d74d5d7a2b23ee056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to indicate that errors should trigger library functions to return error values. <br/></td></tr>
<tr class="separator:gad2e4971120478e0d74d5d7a2b23ee056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a0f9548ba2f8f2d0921374be6fd9e21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a0f9548ba2f8f2d0921374be6fd9e21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6a0f9548ba2f8f2d0921374be6fd9e21">DASERR_DIS_ABORT</a>&#160;&#160;&#160;43</td></tr>
<tr class="memdesc:ga6a0f9548ba2f8f2d0921374be6fd9e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to indicate that errors should trigger program abort with a core dump. <br/></td></tr>
<tr class="separator:ga6a0f9548ba2f8f2d0921374be6fd9e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d3985ce4e92bb37ac7bb45e9a2dd39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac9d3985ce4e92bb37ac7bb45e9a2dd39">das_error</a>(nErrCode,...)&#160;&#160;&#160;das_error_func(__FILE__, __func__, __LINE__, nErrCode, __VA_ARGS__ )</td></tr>
<tr class="memdesc:gac9d3985ce4e92bb37ac7bb45e9a2dd39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal an error condition.  <a href="#gac9d3985ce4e92bb37ac7bb45e9a2dd39">More...</a><br/></td></tr>
<tr class="separator:gac9d3985ce4e92bb37ac7bb45e9a2dd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabef7d61092376db8ddb6481392c9f19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaabef7d61092376db8ddb6481392c9f19"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaabef7d61092376db8ddb6481392c9f19">das_within</a>(A, B, E)&#160;&#160;&#160;(fabs(A - B) &lt; E ? true : false)</td></tr>
<tr class="memdesc:gaabef7d61092376db8ddb6481392c9f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if two floating point values are within an epsilon of each other. <br/></td></tr>
<tr class="separator:gaabef7d61092376db8ddb6481392c9f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga261adfadcb579caea6918a60a8967ebc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga261adfadcb579caea6918a60a8967ebc">DAS_XML_MAXPROPS</a>&#160;&#160;&#160;400</td></tr>
<tr class="memdesc:ga261adfadcb579caea6918a60a8967ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">limit of number of properties per descriptor.  <a href="#ga261adfadcb579caea6918a60a8967ebc">More...</a><br/></td></tr>
<tr class="separator:ga261adfadcb579caea6918a60a8967ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c9fa13b5f1eda73f6ff528327139b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab4c9fa13b5f1eda73f6ff528327139b7">DAS_XML_BUF_LEN</a>&#160;&#160;&#160;1000000</td></tr>
<tr class="memdesc:gab4c9fa13b5f1eda73f6ff528327139b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The limit on xml packet length, in bytes.  <a href="#gab4c9fa13b5f1eda73f6ff528327139b7">More...</a><br/></td></tr>
<tr class="separator:gab4c9fa13b5f1eda73f6ff528327139b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1f44d42d0663329ac249b554970e8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaab1f44d42d0663329ac249b554970e8c">DAS_XML_NODE_NAME_LEN</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:gaab1f44d42d0663329ac249b554970e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The limit of xml element name length, in bytes.  <a href="#gaab1f44d42d0663329ac249b554970e8c">More...</a><br/></td></tr>
<tr class="separator:gaab1f44d42d0663329ac249b554970e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9f7e3a196d85388e6fa0170ab7c39ff7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9f7e3a196d85388e6fa0170ab7c39ff7"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9f7e3a196d85388e6fa0170ab7c39ff7">DasErrCode</a></td></tr>
<tr class="memdesc:ga9f7e3a196d85388e6fa0170ab7c39ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">return code type 0 indicates success, negative integer indicates failure <br/></td></tr>
<tr class="separator:ga9f7e3a196d85388e6fa0170ab7c39ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385da90fd98bb4ef27d154edecbee7d0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga385da90fd98bb4ef27d154edecbee7d0">das_log_handler_t</a> )(int nLevel, const char *sMsg, bool bPrnTime)</td></tr>
<tr class="memdesc:ga385da90fd98bb4ef27d154edecbee7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a message handler function pointer.  <a href="#ga385da90fd98bb4ef27d154edecbee7d0">More...</a><br/></td></tr>
<tr class="separator:ga385da90fd98bb4ef27d154edecbee7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabac27ded4c95e091cb72f4a1818a1f42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabac27ded4c95e091cb72f4a1818a1f42">daslog_level</a> (void)</td></tr>
<tr class="memdesc:gabac27ded4c95e091cb72f4a1818a1f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the log level.  <a href="#gabac27ded4c95e091cb72f4a1818a1f42">More...</a><br/></td></tr>
<tr class="separator:gabac27ded4c95e091cb72f4a1818a1f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f62b22a63a9d3bfd090b49e5ea625e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4f62b22a63a9d3bfd090b49e5ea625e0">daslog_setlevel</a> (int nLevel)</td></tr>
<tr class="memdesc:ga4f62b22a63a9d3bfd090b49e5ea625e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the logging level for this thread.  <a href="#ga4f62b22a63a9d3bfd090b49e5ea625e0">More...</a><br/></td></tr>
<tr class="separator:ga4f62b22a63a9d3bfd090b49e5ea625e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f31ef7d5e3f9d74fa4b429e3f585697"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f31ef7d5e3f9d74fa4b429e3f585697"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4f31ef7d5e3f9d74fa4b429e3f585697">daslog_set_showline</a> (int nLevel)</td></tr>
<tr class="memdesc:ga4f31ef7d5e3f9d74fa4b429e3f585697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output source file and line numbers for messages at or above this level. <br/></td></tr>
<tr class="separator:ga4f31ef7d5e3f9d74fa4b429e3f585697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e58a60eb1861c31ba762fc13761bfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#ga385da90fd98bb4ef27d154edecbee7d0">das_log_handler_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga22e58a60eb1861c31ba762fc13761bfd">daslog_sethandler</a> (<a class="el" href="group__utilities.html#ga385da90fd98bb4ef27d154edecbee7d0">das_log_handler_t</a> new_handler)</td></tr>
<tr class="memdesc:ga22e58a60eb1861c31ba762fc13761bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a new message handler function for this thread.  <a href="#ga22e58a60eb1861c31ba762fc13761bfd">More...</a><br/></td></tr>
<tr class="separator:ga22e58a60eb1861c31ba762fc13761bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084423fd43637bf54496daf868147631"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga084423fd43637bf54496daf868147631">das_init</a> (const char *sProgName, int nErrDis, int nErrBufSz, int nLevel, <a class="el" href="group__utilities.html#ga385da90fd98bb4ef27d154edecbee7d0">das_log_handler_t</a> logfunc)</td></tr>
<tr class="memdesc:ga084423fd43637bf54496daf868147631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize any global structures in the Das2 library.  <a href="#ga084423fd43637bf54496daf868147631">More...</a><br/></td></tr>
<tr class="separator:ga084423fd43637bf54496daf868147631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3035fdc4c5e53cc0d682ba86a9769302"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3035fdc4c5e53cc0d682ba86a9769302">das_abort_on_error</a> (void)</td></tr>
<tr class="memdesc:ga3035fdc4c5e53cc0d682ba86a9769302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling: Trigger Core Dumps.  <a href="#ga3035fdc4c5e53cc0d682ba86a9769302">More...</a><br/></td></tr>
<tr class="separator:ga3035fdc4c5e53cc0d682ba86a9769302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab326d0d85f5beaf9c921387af4c3354b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab326d0d85f5beaf9c921387af4c3354b">das_exit_on_error</a> (void)</td></tr>
<tr class="memdesc:gab326d0d85f5beaf9c921387af4c3354b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling: Normal Exit Set the library to call exit(ErrorCode) when a problem is detected.  <a href="#gab326d0d85f5beaf9c921387af4c3354b">More...</a><br/></td></tr>
<tr class="separator:gab326d0d85f5beaf9c921387af4c3354b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga196c8c8867d939875d66f97fdd327e41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga196c8c8867d939875d66f97fdd327e41">das_return_on_error</a> (void)</td></tr>
<tr class="memdesc:ga196c8c8867d939875d66f97fdd327e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling: Normal Return Set the library to return normally to the calling function with a return value that indicates a problem has occurred.  <a href="#ga196c8c8867d939875d66f97fdd327e41">More...</a><br/></td></tr>
<tr class="separator:ga196c8c8867d939875d66f97fdd327e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c26053b34ee153d27455db320bfa657"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9c26053b34ee153d27455db320bfa657">das_error_disposition</a> (void)</td></tr>
<tr class="memdesc:ga9c26053b34ee153d27455db320bfa657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling: get the library's error disposition.  <a href="#ga9c26053b34ee153d27455db320bfa657">More...</a><br/></td></tr>
<tr class="separator:ga9c26053b34ee153d27455db320bfa657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b47e312e00346dcdf010cd1c832326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad7b47e312e00346dcdf010cd1c832326">das_print_error</a> (void)</td></tr>
<tr class="memdesc:gad7b47e312e00346dcdf010cd1c832326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling: Print formatted error to standard error stream Set the library to ouput formatted error messages to the processes standard error stream.  <a href="#gad7b47e312e00346dcdf010cd1c832326">More...</a><br/></td></tr>
<tr class="separator:gad7b47e312e00346dcdf010cd1c832326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07cc55ede515509fb863664355659ca2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga07cc55ede515509fb863664355659ca2">das_save_error</a> (int maxmsg)</td></tr>
<tr class="memdesc:ga07cc55ede515509fb863664355659ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling: Save formatted error in a message buffer.  <a href="#ga07cc55ede515509fb863664355659ca2">More...</a><br/></td></tr>
<tr class="separator:ga07cc55ede515509fb863664355659ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a18feda5370b07efe17e1abcef9a89"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae0a18feda5370b07efe17e1abcef9a89">das_lib_version</a> (void)</td></tr>
<tr class="memdesc:gae0a18feda5370b07efe17e1abcef9a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the library version.  <a href="#gae0a18feda5370b07efe17e1abcef9a89">More...</a><br/></td></tr>
<tr class="separator:gae0a18feda5370b07efe17e1abcef9a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55d67cc25ba9535f4c03568ae12d9e65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga55d67cc25ba9535f4c03568ae12d9e65">das_assert_valid_id</a> (const char *sId)</td></tr>
<tr class="memdesc:ga55d67cc25ba9535f4c03568ae12d9e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that a string is suitable for use as an object ID.  <a href="#ga55d67cc25ba9535f4c03568ae12d9e65">More...</a><br/></td></tr>
<tr class="separator:ga55d67cc25ba9535f4c03568ae12d9e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d43e741c7a16bb4328a89d000e2ee98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4d43e741c7a16bb4328a89d000e2ee98">das_store_str</a> (char **psDest, size_t *puLen, const char *sSrc)</td></tr>
<tr class="memdesc:ga4d43e741c7a16bb4328a89d000e2ee98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store string in a buffer that is reallocated if need be.  <a href="#ga4d43e741c7a16bb4328a89d000e2ee98">More...</a><br/></td></tr>
<tr class="separator:ga4d43e741c7a16bb4328a89d000e2ee98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec49615eae33d0b575e61ee8709fe1e1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaec49615eae33d0b575e61ee8709fe1e1">das_string</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:gaec49615eae33d0b575e61ee8709fe1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new string on the heap and format it.  <a href="#gaec49615eae33d0b575e61ee8709fe1e1">More...</a><br/></td></tr>
<tr class="separator:gaec49615eae33d0b575e61ee8709fe1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53b58480bfbdc078cd964184fe5505b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab53b58480bfbdc078cd964184fe5505b">das_strdup</a> (const char *sIn)</td></tr>
<tr class="memdesc:gab53b58480bfbdc078cd964184fe5505b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string into a new buffer allocated on the heap.  <a href="#gab53b58480bfbdc078cd964184fe5505b">More...</a><br/></td></tr>
<tr class="separator:gab53b58480bfbdc078cd964184fe5505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b2311fb2e8636dee57875e75bc23ea"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab3b2311fb2e8636dee57875e75bc23ea">das_vstring</a> (const char *fmt, va_list ap)</td></tr>
<tr class="memdesc:gab3b2311fb2e8636dee57875e75bc23ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a formatted string in a newly allocated buffer.  <a href="#gab3b2311fb2e8636dee57875e75bc23ea">More...</a><br/></td></tr>
<tr class="separator:gab3b2311fb2e8636dee57875e75bc23ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga170e0a1a41236c8b8e97cca23bfe9e5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga170e0a1a41236c8b8e97cca23bfe9e5e">das_isdir</a> (const char *path)</td></tr>
<tr class="memdesc:ga170e0a1a41236c8b8e97cca23bfe9e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the path a directory.  <a href="#ga170e0a1a41236c8b8e97cca23bfe9e5e">More...</a><br/></td></tr>
<tr class="separator:ga170e0a1a41236c8b8e97cca23bfe9e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab14e6af114ec88927af282cbe334ad67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab14e6af114ec88927af282cbe334ad67">das_isfile</a> (const char *path)</td></tr>
<tr class="memdesc:gab14e6af114ec88927af282cbe334ad67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the path a file.  <a href="#gab14e6af114ec88927af282cbe334ad67">More...</a><br/></td></tr>
<tr class="separator:gab14e6af114ec88927af282cbe334ad67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c84f5535e846631e48e14e1252bbe2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7c84f5535e846631e48e14e1252bbe2c">das_dirlist</a> (const char *sPath, char ppDirList[][256], size_t uMaxDirs, char cType)</td></tr>
<tr class="memdesc:ga7c84f5535e846631e48e14e1252bbe2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sorted directory listing.  <a href="#ga7c84f5535e846631e48e14e1252bbe2c">More...</a><br/></td></tr>
<tr class="separator:ga7c84f5535e846631e48e14e1252bbe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ba29a2c56bc94a222885261d9b5f464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdas__error__msg.html">das_error_msg</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6ba29a2c56bc94a222885261d9b5f464">das_get_error</a> (void)</td></tr>
<tr class="memdesc:ga6ba29a2c56bc94a222885261d9b5f464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the saved das2 error message buffer.  <a href="#ga6ba29a2c56bc94a222885261d9b5f464">More...</a><br/></td></tr>
<tr class="separator:ga6ba29a2c56bc94a222885261d9b5f464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67a9f7a0cd1cc7ef7e9c89284a92899b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga67a9f7a0cd1cc7ef7e9c89284a92899b">das_error_free</a> (<a class="el" href="structdas__error__msg.html">das_error_msg</a> *pMsg)</td></tr>
<tr class="memdesc:ga67a9f7a0cd1cc7ef7e9c89284a92899b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an error message structure allocated on the heap.  <a href="#ga67a9f7a0cd1cc7ef7e9c89284a92899b">More...</a><br/></td></tr>
<tr class="separator:ga67a9f7a0cd1cc7ef7e9c89284a92899b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gac9d3985ce4e92bb37ac7bb45e9a2dd39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define das_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nErrCode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;das_error_func(__FILE__, __func__, __LINE__, nErrCode, __VA_ARGS__ )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal an error condition. </p>
<p>This routine is called throughout the code when an error condition arrises.</p>
<p>The default handler for error conditions prints the message provided to the standard error channel and then calls exit(nErrCode). To have the library call your handler instead use the das_set_error_handler() function. To have the library abort with a core dump on an error use <a class="el" href="group__utilities.html#ga3035fdc4c5e53cc0d682ba86a9769302" title="Error handling: Trigger Core Dumps. ">das_abort_on_error()</a>.</p>
<p>Each source file in the code has it's own error code. Though it's probably not that useful to end users, the codes are provided here:</p>
<ul>
<li><b>8</b> : Not yet implemented - DASERR_NOTIMP</li>
<li><b>9</b> : Assertion Failures - DASERR_ASSERT</li>
<li><b>10</b> : das1.c - D1ERR</li>
<li><b>11</b> : Lib initialization errors - DASERR_INIT</li>
<li><b>12</b> : buffer.c - DASERR_BUF</li>
<li><b>13</b> : util.c - DASERR_UTIL</li>
<li><b>14</b> : encoding.c - DASERR_ENC</li>
<li><b>15</b> : units.c - DASERR_UNITS</li>
<li><b>16</b> : descriptor.c - DASERR_DESC</li>
<li><b>17</b> : plane.c - DASERR_PLANE</li>
<li><b>18</b> : packet.c - DASERR_PKT</li>
<li><b>19</b> : stream.c - DASERR_STREAM</li>
<li><b>20</b> : oob.c - DASERR_OOB</li>
<li><b>21</b> : io.c - DASERR_IO</li>
<li><b>22</b> : dsdf.c - DASERR_DSDF</li>
<li><b>23</b> : dft.c - DASERR_DFT</li>
<li><b>24</b> : log.c - DASERR_LOG</li>
<li><b>25</b> : array.c - DASERR_ARRAY</li>
<li><b>26</b> : variable.c - DASERR_VAR</li>
<li><b>27</b> : dimension.c - DASERR_DIM</li>
<li><b>28</b> : dataset.c - DASERR_DS</li>
<li><b>29</b> : builder.c - DASERR_BLDR</li>
<li><b>30</b> : http.c - DASERR_HTTP</li>
<li><b>31</b> : datum.c - DASERR_DATUM</li>
<li><b>32</b> : value.c - DASERR_VALUE</li>
<li><b>34</b> : operater.c - DASERR_OP</li>
<li><b>35</b> : credentials.c - DASERR_CRED</li>
<li><b>36</b> : catalog.c - DASERR_CAT</li>
</ul>
<p>Application programs are recommended to use values 64 and above to avoid colliding with future das2 error codes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nErrCode</td><td>The value to return to the shell, should be one of the above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>By default this function never returns but if the libdas2 error disposition has been set to DAS2_ERRDIS_RET then the value of nErrCode is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga261adfadcb579caea6918a60a8967ebc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DAS_XML_MAXPROPS&#160;&#160;&#160;400</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>limit of number of properties per descriptor. </p>

</div>
</div>
<a class="anchor" id="gab4c9fa13b5f1eda73f6ff528327139b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DAS_XML_BUF_LEN&#160;&#160;&#160;1000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The limit on xml packet length, in bytes. </p>
<p>(ascii encoding.) </p>

</div>
</div>
<a class="anchor" id="gaab1f44d42d0663329ac249b554970e8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DAS_XML_NODE_NAME_LEN&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The limit of xml element name length, in bytes. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga385da90fd98bb4ef27d154edecbee7d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* das_log_handler_t)(int nLevel, const char *sMsg, bool bPrnTime)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of a message handler function pointer. </p>
<p>Message handlers need to be prepared for any of the string pointers sMsg, sDataStatus, or sStackTrace to be null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nLevel</td><td>The message level. If nLevel is equal to or greater than das_log_getlevel() then the message should be logged.</td></tr>
    <tr><td class="paramname">sMsg</td><td>The message, usually not null.</td></tr>
    <tr><td class="paramname">bPrnTime</td><td>The current system time should be included in the log output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gabac27ded4c95e091cb72f4a1818a1f42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daslog_level </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the log level. </p>
<dl class="section return"><dt>Returns</dt><dd>one of: DAS_LL_CRIT, DAS_LL_ERROR, DAS_LL_WARN, DAS_LL_INFO, DAS_LL_DEBUG, DAS_LL_TRACE </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f62b22a63a9d3bfd090b49e5ea625e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int daslog_setlevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the logging level for this thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nLevel</td><td>Set to one of<ul>
<li>DASLOG_TRACE</li>
<li>DASLOG_DEBUG</li>
<li>DASLOG_NOTICE</li>
<li>DASLOG_WARN</li>
<li>DASLOG_ERROR</li>
<li>DASLOG_CRITICAL</li>
<li>DASLOG_NOTHING</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous log level. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22e58a60eb1861c31ba762fc13761bfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#ga385da90fd98bb4ef27d154edecbee7d0">das_log_handler_t</a> daslog_sethandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utilities.html#ga385da90fd98bb4ef27d154edecbee7d0">das_log_handler_t</a>&#160;</td>
          <td class="paramname"><em>new_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install a new message handler function for this thread. </p>
<p>The default message handler just prints to stderr, which is not very effecient, nor is it appropriate for GUI applications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_handler</td><td>The new message handler, or NULL to set to the default handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous message handler function pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga084423fd43637bf54496daf868147631"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void das_init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sProgName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nErrDis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nErrBufSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utilities.html#ga385da90fd98bb4ef27d154edecbee7d0">das_log_handler_t</a>&#160;</td>
          <td class="paramname"><em>logfunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize any global structures in the Das2 library. </p>
<p>This should be the first function your program calls before using any libdas2 functions. In general libdas2 tries to avoid global structures but does use them in three areas:</p>
<ul>
<li>Error and log handling - Since the error and logging disposition should be the same for all library calls handlers are set here</li>
<li>Unit conversions - Since das_unit varibles should be comparible using a simple equality test, a global registry of const char pointers is needed</li>
<li>FFTW plan mutexes - Since the FFTW library unfortunatly uses global plan memory</li>
<li>OpenSSL Contex mutexes - The openssl library contex cannot be changed by multiple threads at the same time, a mutex is setup to prevent this from happening</li>
</ul>
<p>This function initializes defaults for the items above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sProgName</td><td>The name of the program using the library. Used in some error messages.</td></tr>
    <tr><td class="paramname">nErrDis</td><td>Set the behavior the library takes when an error is encountered. May be one of DASERR_DIS_EXIT, call exit() when an error occurs; DASERR_DIS_RET, return with an error code; or DASERR_DIS_ABORT, call abort(). The value of DASERR_DIS_EXIT is 0 so you can use that for the default behavior. If DASERR_DIS_RET is used, the function <a class="el" href="group__utilities.html#ga6ba29a2c56bc94a222885261d9b5f464" title="Return the saved das2 error message buffer. ">das_get_error()</a> can be used to retrieve the most recent error message.</td></tr>
    <tr><td class="paramname">nErrBufSz</td><td>If not zero, a global error message buffer will be allocated that is this many bytes long and error message will be saved into the buffer instead of being sent to the standard error channel. Messages can be retrieved via <a class="el" href="group__utilities.html#ga6ba29a2c56bc94a222885261d9b5f464" title="Return the saved das2 error message buffer. ">das_get_error()</a>. If zero, these will be send to the standard error channel as soon as they occur. Saving errors is only useful if the error disposition is DAS2_ERRDIS_RET as otherwise the program exits before the message can be output.</td></tr>
    <tr><td class="paramname">nLevel</td><td>Set the logging level to one of, DASLOG_TRACE, DASLOG_DEBUG, DASLOG_NOTICE, DASLOG_WARN, DASLOG_ERROR, DASLOG_CRITICAL.</td></tr>
    <tr><td class="paramname">logfunc</td><td>A callback for handling log messages. The callback need not be thread safe as it will only be triggered inside mutual exclusion (mutex) locks. If NULL messages are printed to the stardard error channel.</td></tr>
  </table>
  </dd>
</dl>
<p>The error disposition does not affect any errors that are encountered within das_init. Errors should not occur during initialization, any that do trigger a call to exit() </p>

</div>
</div>
<a class="anchor" id="ga3035fdc4c5e53cc0d682ba86a9769302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void das_abort_on_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handling: Trigger Core Dumps. </p>
<p>Call this function to have the library exit via an abort() call instead of using exit(ErrorCode). On most systems this will trigger the generation of a core file that can be used for debugging. </p>
<dl class="section warning"><dt>Warning</dt><dd>: Calling this function prevents open file handles from being flushed to disk which will typically result in corrupted output. </dd></dl>

</div>
</div>
<a class="anchor" id="gab326d0d85f5beaf9c921387af4c3354b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void das_exit_on_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handling: Normal Exit Set the library to call exit(ErrorCode) when a problem is detected. </p>
<p>This is usually what you want and the library's default setting. </p>

</div>
</div>
<a class="anchor" id="ga196c8c8867d939875d66f97fdd327e41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void das_return_on_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handling: Normal Return Set the library to return normally to the calling function with a return value that indicates a problem has occurred. </p>
<p>This will be the new default, but is not yet tested. </p>

</div>
</div>
<a class="anchor" id="ga9c26053b34ee153d27455db320bfa657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int das_error_disposition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handling: get the library's error disposition. </p>
<dl class="section return"><dt>Returns</dt><dd>one of the following integers:<ul>
<li>DAS2_ERRDIS_EXIT - Library exits when there is a problem</li>
<li>DAS2_ERRDIS_ABORT - Library aborts, possibly with core dump on a problem</li>
<li>DAS2_ERRDIS_RET - Library returns normally with an error code </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad7b47e312e00346dcdf010cd1c832326"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void das_print_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handling: Print formatted error to standard error stream Set the library to ouput formatted error messages to the processes standard error stream. </p>
<p>This is the default. </p>

</div>
</div>
<a class="anchor" id="ga07cc55ede515509fb863664355659ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_save_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxmsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handling: Save formatted error in a message buffer. </p>
<p>Set the library to save formatted error message to a message buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxmsg</td><td>maximum message size. The buffer created will be maxmsg in length, meaning any formatted messages longer than the available buffer size will be truncated to maxmsg-1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if error buffer setup was successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0a18feda5370b07efe17e1abcef9a89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* das_lib_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the library version. </p>
<dl class="section return"><dt>Returns</dt><dd>the version tag string for the das2 core library, or the string "untagged" if the version is unknown </dd></dl>

</div>
</div>
<a class="anchor" id="ga55d67cc25ba9535f4c03568ae12d9e65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_assert_valid_id </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that a string is suitable for use as an object ID. </p>
<p>Object ID strings are ascii strings using only characters from the set a-z, A-Z, 0-9, and _. They do not start with a number. They are no more than 63 bytes long. Basically they can be used as variable names in most programming languages.</p>
<p>If the das_error_disposition is set to exit this function never returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sId</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string can be used as an ID, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d43e741c7a16bb4328a89d000e2ee98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void das_store_str </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>psDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>puLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store string in a buffer that is reallocated if need be. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDest</td><td>a pointer to the storage location </td></tr>
    <tr><td class="paramname">puLen</td><td>a pointer to the size of the storage location </td></tr>
    <tr><td class="paramname">sSrc</td><td>the source string to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec49615eae33d0b575e61ee8709fe1e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* das_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new string on the heap and format it. </p>
<p>Except for using das_error on a failure, this is a copy of the code out of man 3 printf on Linux.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated and formatted string on the heap, or NULL if the function failed and the das2 error disposition allows for continuation after a failure </dd></dl>

</div>
</div>
<a class="anchor" id="gab53b58480bfbdc078cd964184fe5505b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* das_strdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string into a new buffer allocated on the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sIn</td><td>the string to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated buffer containing the same characters as the input string or NULL if the input length was zero </dd></dl>

</div>
</div>
<a class="anchor" id="gab3b2311fb2e8636dee57875e75bc23ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* das_vstring </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a formatted string in a newly allocated buffer. </p>
<p>This version is suitable for calling from variable argument functions.</p>
<p>Except for using das_error on a failure, this is a copy of the code out of man 3 printf on Linux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>- a printf format string </td></tr>
    <tr><td class="paramname">ap</td><td>A va_list list, see vfprintf or stdarg.h for details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated and formatted string on the heap, or NULL if the function failed and the das2 error disposition allows for continuation after a failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga170e0a1a41236c8b8e97cca23bfe9e5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_isdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the path a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The directory in question, passed to stat(2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <b>path</b> can be determined to be a directory, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gab14e6af114ec88927af282cbe334ad67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_isfile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the path a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file in question, passed to stat(2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <b>path</b> can be determined to be a file, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c84f5535e846631e48e14e1252bbe2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int das_dirlist </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ppDirList</em>[][256], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uMaxDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>cType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a sorted directory listing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sPath</td><td>The path to the directory to read.</td></tr>
    <tr><td class="paramname">ppDirList</td><td>A pointer to a 2-D character array where the first index is the directory item and the second index is the character position. The max value of the second index <b>must</b> be = NAME_MAX - 1. The value NAME_MAX is defined in the POSIX header limits.h</td></tr>
    <tr><td class="paramname">uMaxDirs</td><td>The maximum number of directory entries that may be stored<ul>
<li></li>
</ul>
</td></tr>
    <tr><td class="paramname">cType</td><td>May be used to filter the items returned. If cType = 'f' only files will be return, if cType = 'd' then only directories will be returned. Any other value, including 0 will return both.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success the number of items in the directory not counting '.' and '..' are returned, on failure a negative error code is returned. Item names are sorted before return. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ba29a2c56bc94a222885261d9b5f464"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdas__error__msg.html">das_error_msg</a> * das_get_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the saved das2 error message buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>an instance of Das2ErrorMessage. The struct returned contains the error code, formatted message, max message size, and the source file, function name, and line number of where the message originated. </dd></dl>

</div>
</div>
<a class="anchor" id="ga67a9f7a0cd1cc7ef7e9c89284a92899b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void das_error_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdas__error__msg.html">das_error_msg</a> *&#160;</td>
          <td class="paramname"><em>pMsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an error message structure allocated on the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMsg</td><td>the message buffer to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
