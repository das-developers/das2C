<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libdas2: Values</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="das2logo-32.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">libdas2
   </div>
   <div id="projectbrief">das2 core C utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Values</div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic data storage elements.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Basic data storage elements. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdas__datum.html">das_datum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value and it's units.  <a href="structdas__datum.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9fa21903750ece99a63d910589406927"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9fa21903750ece99a63d910589406927"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga9fa21903750ece99a63d910589406927">das_valcmp_func</a> )(const void *, const void *)</td></tr>
<tr class="memdesc:ga9fa21903750ece99a63d910589406927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison functions look like this. <br/></td></tr>
<tr class="separator:ga9fa21903750ece99a63d910589406927"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae1a009ee25910c8514f20225eb13f530"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> { <br/>
&#160;&#160;<a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530acd357630ae0ef37f194c322b8e7aaa89">vtUnknown</a> = 0
, <a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530a0b48e9f85996bca01cbc4ef867a14d87">vtByte</a>, 
<a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530ac447f3d9dd9e4b250990ede36457e9c6">vtUShort</a>, 
<a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530a0fe203efac33a548bb0793cbd6a4be9f">vtShort</a>, 
<br/>
&#160;&#160;<a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530a3c0bd6e9190ffefd8bfd656b32d1cb09">vtInt</a>, 
<a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530aa6df9ef15e5ff7578d1691627921c141">vtLong</a>, 
<a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530a2dde9d0564f21ee871eadd6a45fc59db">vtFloat</a>, 
<a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530afd6ca1d04415b7534d47a76ddd27aca8">vtDouble</a>, 
<br/>
&#160;&#160;<a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530adab1a2519cac5ff5d04d295ebc90f618">vtTime</a>, 
<a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530aaa403f3a4de6b73d20d8ed606d1aa9ff">vtText</a>, 
<a class="el" href="group__values.html#ggae1a009ee25910c8514f20225eb13f530aea5926c173c777754c86cd0a6b5c8445">vtByteSeq</a>
<br/>
 }</td></tr>
<tr class="memdesc:gae1a009ee25910c8514f20225eb13f530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of types stored in Das Array (<a class="el" href="structDasAry.html" title="Dynamic recursive ragged arrays. ">DasAry</a>) objects Not that any kind of value may be stored in a Das Array, but most of these types have runtime type safty checks.  <a href="group__values.html#gae1a009ee25910c8514f20225eb13f530">More...</a><br/></td></tr>
<tr class="separator:gae1a009ee25910c8514f20225eb13f530"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad62c275e9ac9fd535c1451126f658477"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gad62c275e9ac9fd535c1451126f658477">das_datum_fromStr</a> (<a class="el" href="structdas__datum.html">das_datum</a> *pThis, const char *sStr)</td></tr>
<tr class="memdesc:gad62c275e9ac9fd535c1451126f658477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a numeric datum from a value and units string.  <a href="#gad62c275e9ac9fd535c1451126f658477">More...</a><br/></td></tr>
<tr class="separator:gad62c275e9ac9fd535c1451126f658477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1800c49ec8928a14013ab973f5cc7a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gae1800c49ec8928a14013ab973f5cc7a6">das_datum_fromDbl</a> (<a class="el" href="structdas__datum.html">das_datum</a> *pThis, double value, <a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a> units)</td></tr>
<tr class="memdesc:gae1800c49ec8928a14013ab973f5cc7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a datum from a double value and units.  <a href="#gae1800c49ec8928a14013ab973f5cc7a6">More...</a><br/></td></tr>
<tr class="separator:gae1800c49ec8928a14013ab973f5cc7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc9283706af51789f02022266cc23ff3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gafc9283706af51789f02022266cc23ff3">das_datum_wrapStr</a> (<a class="el" href="structdas__datum.html">das_datum</a> *pTHis, const char *sStr, <a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a> units)</td></tr>
<tr class="memdesc:gafc9283706af51789f02022266cc23ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an external string as a datum.  <a href="#gafc9283706af51789f02022266cc23ff3">More...</a><br/></td></tr>
<tr class="separator:gafc9283706af51789f02022266cc23ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab641343760115e1b2ccab980bba6a4c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gab641343760115e1b2ccab980bba6a4c9">das_datum_byteSeq</a> (<a class="el" href="structdas__datum.html">das_datum</a> *pThis, das_byteseq seq, <a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a> units)</td></tr>
<tr class="memdesc:gab641343760115e1b2ccab980bba6a4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an external unknown type pointer as a datum.  <a href="#gab641343760115e1b2ccab980bba6a4c9">More...</a><br/></td></tr>
<tr class="separator:gab641343760115e1b2ccab980bba6a4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33090eb744b272db5bab0c36b451926d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga33090eb744b272db5bab0c36b451926d">das_datum_toStr</a> (const <a class="el" href="structdas__datum.html">das_datum</a> *pThis, char *sStr, size_t uLen, int nFracDigits)</td></tr>
<tr class="memdesc:ga33090eb744b272db5bab0c36b451926d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a UTF-8 string representation of a datum to a buffer.  <a href="#ga33090eb744b272db5bab0c36b451926d">More...</a><br/></td></tr>
<tr class="separator:ga33090eb744b272db5bab0c36b451926d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae545b907854395f6924272273f1b6b4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gaae545b907854395f6924272273f1b6b4">das_datum_toStrValOnly</a> (const <a class="el" href="structdas__datum.html">das_datum</a> *pThis, char *sStr, size_t uLen, int nFracDigits)</td></tr>
<tr class="memdesc:gaae545b907854395f6924272273f1b6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as das_datum_toStr, but never print the units.  <a href="#gaae545b907854395f6924272273f1b6b4">More...</a><br/></td></tr>
<tr class="separator:gaae545b907854395f6924272273f1b6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37954af0d57f1908d1a2e8d1024461d9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga37954af0d57f1908d1a2e8d1024461d9">das_datum_toDbl</a> (const <a class="el" href="structdas__datum.html">das_datum</a> *pThis)</td></tr>
<tr class="memdesc:ga37954af0d57f1908d1a2e8d1024461d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a datum value as a double.  <a href="#ga37954af0d57f1908d1a2e8d1024461d9">More...</a><br/></td></tr>
<tr class="separator:ga37954af0d57f1908d1a2e8d1024461d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0bc2288f2c65def16a0c30523e29fd2"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gaf0bc2288f2c65def16a0c30523e29fd2">das_vt_fill</a> (<a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> vt)</td></tr>
<tr class="memdesc:gaf0bc2288f2c65def16a0c30523e29fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default fill value for a given element type.  <a href="#gaf0bc2288f2c65def16a0c30523e29fd2">More...</a><br/></td></tr>
<tr class="separator:gaf0bc2288f2c65def16a0c30523e29fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8c26e424b36c1c9ade517a9915dd93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd8c26e424b36c1c9ade517a9915dd93"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gafd8c26e424b36c1c9ade517a9915dd93">das_vt_size</a> (<a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> vt)</td></tr>
<tr class="memdesc:gafd8c26e424b36c1c9ade517a9915dd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size in bytes for a given element type. <br/></td></tr>
<tr class="separator:gafd8c26e424b36c1c9ade517a9915dd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a4b74c01896ff6f565de9d5364bac5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a4b74c01896ff6f565de9d5364bac5d"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga6a4b74c01896ff6f565de9d5364bac5d">das_vt_toStr</a> (<a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> vt)</td></tr>
<tr class="memdesc:ga6a4b74c01896ff6f565de9d5364bac5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a text string representation of an element type. <br/></td></tr>
<tr class="separator:ga6a4b74c01896ff6f565de9d5364bac5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3738511474a7bbf848c31f7fd92bb06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab3738511474a7bbf848c31f7fd92bb06"></a>
<a class="el" href="group__values.html#ga9fa21903750ece99a63d910589406927">das_valcmp_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gab3738511474a7bbf848c31f7fd92bb06">das_vt_getcmp</a> (<a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> vt)</td></tr>
<tr class="memdesc:gab3738511474a7bbf848c31f7fd92bb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the comparison function for two values of this type. <br/></td></tr>
<tr class="separator:gab3738511474a7bbf848c31f7fd92bb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad57fd6192612b988a462047161ff35d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gad57fd6192612b988a462047161ff35d4">das_vt_merge</a> (<a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> right, int op, <a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> left)</td></tr>
<tr class="memdesc:gad57fd6192612b988a462047161ff35d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">What would be the resulting type given an operation on the given value type.  <a href="#gad57fd6192612b988a462047161ff35d4">More...</a><br/></td></tr>
<tr class="separator:gad57fd6192612b988a462047161ff35d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa05c3654d91cd080a9e38f6ba4bcbcc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gaa05c3654d91cd080a9e38f6ba4bcbcc4">das_str2double</a> (const char *str, double *pRes)</td></tr>
<tr class="memdesc:gaa05c3654d91cd080a9e38f6ba4bcbcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string value to a 8-byte float, similar to strtod(3).  <a href="#gaa05c3654d91cd080a9e38f6ba4bcbcc4">More...</a><br/></td></tr>
<tr class="separator:gaa05c3654d91cd080a9e38f6ba4bcbcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03f95628539dcb28890229288649ccef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga03f95628539dcb28890229288649ccef">das_str2int</a> (const char *str, int *pRes)</td></tr>
<tr class="memdesc:ga03f95628539dcb28890229288649ccef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the initial portion of a string to an integer with explicit over/underflow checks.  <a href="#ga03f95628539dcb28890229288649ccef">More...</a><br/></td></tr>
<tr class="separator:ga03f95628539dcb28890229288649ccef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga612a226dc8f4f78200187d9713ab7f71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga612a226dc8f4f78200187d9713ab7f71">das_str2bool</a> (const char *str, bool *pRes)</td></tr>
<tr class="memdesc:ga612a226dc8f4f78200187d9713ab7f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string value to a boolean value.  <a href="#ga612a226dc8f4f78200187d9713ab7f71">More...</a><br/></td></tr>
<tr class="separator:ga612a226dc8f4f78200187d9713ab7f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb20d9148ec64c45c5b4f430ba95c58a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gacb20d9148ec64c45c5b4f430ba95c58a">das_str2baseint</a> (const char *str, int base, int *pRes)</td></tr>
<tr class="memdesc:gacb20d9148ec64c45c5b4f430ba95c58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to an integer with explicit base and overflow checking.  <a href="#gacb20d9148ec64c45c5b4f430ba95c58a">More...</a><br/></td></tr>
<tr class="separator:gacb20d9148ec64c45c5b4f430ba95c58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c94ef724db4e6893617c6061208e2a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#ga1c94ef724db4e6893617c6061208e2a9">das_strn2baseint</a> (const char *str, int nLen, int base, int *pRes)</td></tr>
<tr class="memdesc:ga1c94ef724db4e6893617c6061208e2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an explicit length string to an integer with explicit base with over/underflow checks.  <a href="#ga1c94ef724db4e6893617c6061208e2a9">More...</a><br/></td></tr>
<tr class="separator:ga1c94ef724db4e6893617c6061208e2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb99fd0d12418a0b8f086123be132c9c"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gadb99fd0d12418a0b8f086123be132c9c">das_csv2doubles</a> (const char *s, int *nitems)</td></tr>
<tr class="memdesc:gadb99fd0d12418a0b8f086123be132c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a comma separated list of ASCII values into a double array.  <a href="#gadb99fd0d12418a0b8f086123be132c9c">More...</a><br/></td></tr>
<tr class="separator:gadb99fd0d12418a0b8f086123be132c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f3b3b3dfb9cd9413c1de768cf2bd18"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__values.html#gaa1f3b3b3dfb9cd9413c1de768cf2bd18">das_doubles2csv</a> (char *buf, const double *value, int nitems)</td></tr>
<tr class="memdesc:gaa1f3b3b3dfb9cd9413c1de768cf2bd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an array of doubles into a string buffer.  <a href="#gaa1f3b3b3dfb9cd9413c1de768cf2bd18">More...</a><br/></td></tr>
<tr class="separator:gaa1f3b3b3dfb9cd9413c1de768cf2bd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gae1a009ee25910c8514f20225eb13f530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of types stored in Das Array (<a class="el" href="structDasAry.html" title="Dynamic recursive ragged arrays. ">DasAry</a>) objects Not that any kind of value may be stored in a Das Array, but most of these types have runtime type safty checks. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggae1a009ee25910c8514f20225eb13f530acd357630ae0ef37f194c322b8e7aaa89"></a>vtUnknown</em>&nbsp;</td><td class="fielddoc">
<p>For generic storage, designates elements as unknown, you have to cast the array return values yourself. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae1a009ee25910c8514f20225eb13f530a0b48e9f85996bca01cbc4ef867a14d87"></a>vtByte</em>&nbsp;</td><td class="fielddoc">
<p>Indicates array values are unsigned 8-bit unsigned integers (bytes) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae1a009ee25910c8514f20225eb13f530ac447f3d9dd9e4b250990ede36457e9c6"></a>vtUShort</em>&nbsp;</td><td class="fielddoc">
<p>Indicates array values are unsigned 16-bit integers (shorts) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae1a009ee25910c8514f20225eb13f530a0fe203efac33a548bb0793cbd6a4be9f"></a>vtShort</em>&nbsp;</td><td class="fielddoc">
<p>Indicates array values are signed 16-bit integers (shorts) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae1a009ee25910c8514f20225eb13f530a3c0bd6e9190ffefd8bfd656b32d1cb09"></a>vtInt</em>&nbsp;</td><td class="fielddoc">
<p>Indicates array values are signed 32-bit integers (ints) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae1a009ee25910c8514f20225eb13f530aa6df9ef15e5ff7578d1691627921c141"></a>vtLong</em>&nbsp;</td><td class="fielddoc">
<p>Indicates array values are signed 64-bit integers (longs) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae1a009ee25910c8514f20225eb13f530a2dde9d0564f21ee871eadd6a45fc59db"></a>vtFloat</em>&nbsp;</td><td class="fielddoc">
<p>Indicates array values are 32-bit floating point values (floats) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae1a009ee25910c8514f20225eb13f530afd6ca1d04415b7534d47a76ddd27aca8"></a>vtDouble</em>&nbsp;</td><td class="fielddoc">
<p>Indicates array values are 64-bit floating point values (doubles) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae1a009ee25910c8514f20225eb13f530adab1a2519cac5ff5d04d295ebc90f618"></a>vtTime</em>&nbsp;</td><td class="fielddoc">
<p>Indicates array values are das_time_t structures. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae1a009ee25910c8514f20225eb13f530aaa403f3a4de6b73d20d8ed606d1aa9ff"></a>vtText</em>&nbsp;</td><td class="fielddoc">
<p>Indicates datum values are const char* pointers to null terminated UTF-8 strings. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae1a009ee25910c8514f20225eb13f530aea5926c173c777754c86cd0a6b5c8445"></a>vtByteSeq</em>&nbsp;</td><td class="fielddoc">
<p>Indicates datum values are size_t plus const byte* pairs, no more is known about the bytes. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad62c275e9ac9fd535c1451126f658477"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_datum_fromStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdas__datum.html">das_datum</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a numeric datum from a value and units string. </p>
<p>Note that this function will not initialize text datums. This is because text datums only carry a const char* pointer, but not the string itself. Call Datum_wrapStr() to make text datums.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>pointer to the datum structure to initialize </td></tr>
    <tr><td class="paramname">sStr</td><td>the value plus it's units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the string was parseable as a datum, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gae1800c49ec8928a14013ab973f5cc7a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_datum_fromDbl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdas__datum.html">das_datum</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a>&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a datum from a double value and units. </p>
<p>This is the most commonly used type of datum, followed by time datums</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">units</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns true. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc9283706af51789f02022266cc23ff3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_datum_wrapStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdas__datum.html">das_datum</a> *&#160;</td>
          <td class="paramname"><em>pTHis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a>&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap an external string as a datum. </p>
<p>This is useful for events lists as well as non-numeric coordinate points. For example: </p>
<div class="fragment"><div class="line">*</div>
<div class="line">* <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>** cites[] = {</div>
<div class="line">*    <span class="stringliteral">&quot;Iowa City&quot;</span>, <span class="stringliteral">&quot;Coralville&quot;</span>, <span class="stringliteral">&quot;North Liberty&quot;</span>, <span class="stringliteral">&quot;Cedar Rapids&quot;</span></div>
<div class="line">* };</div>
<div class="line">*</div>
<div class="line">* Make a datum array representing a few cities in Eastern Iowa with units</div>
<div class="line">* of <span class="stringliteral">&quot;city&quot;</span>.</div>
<div class="line">*</div>
<div class="line">* datum locations[4];</div>
<div class="line">* <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i)</div>
<div class="line">*     das_datum_initStr(locations + i, <span class="stringliteral">&quot;city&quot;</span>, cities[i]);</div>
<div class="line">*</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gab641343760115e1b2ccab980bba6a4c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_datum_byteSeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdas__datum.html">das_datum</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">das_byteseq&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__units.html#ga2bc8c1ed367dae6aa95343e31578749b">das_units</a>&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap an external unknown type pointer as a datum. </p>
<p>This is for special user defined data types unknown to libdas2. The type of the datum will be vtByteSeq (a byte sequence) </p>

</div>
</div>
<a class="anchor" id="ga33090eb744b272db5bab0c36b451926d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* das_datum_toStr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdas__datum.html">das_datum</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFracDigits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a UTF-8 string representation of a datum to a buffer. </p>
<p>Time values are printed as ISO-8601 time strings, all floating point values are printed using a generic exponential notation. String datums are simply printed, and byteseq datums are printed as hex-digits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td>The datum to write</td></tr>
    <tr><td class="paramname">sStr</td><td>The buffer to write the reprenestation to</td></tr>
    <tr><td class="paramname">uLen</td><td>The amount of space available for writing</td></tr>
    <tr><td class="paramname">nFracDigits</td><td>Number of digits after the decimal place to print. for multi-part values, such a calendar times this refers to the number of digits after the decimal point for the last component only. Use -1 to get default fractional digits which are 5 for a float, 9 for a double and millisec precision for times.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The write point for adding more text to the buffer. To see how much text was written subtract the initial buffer (sBuf) from this return value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaae545b907854395f6924272273f1b6b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* das_datum_toStrValOnly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdas__datum.html">das_datum</a> *&#160;</td>
          <td class="paramname"><em>pThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFracDigits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as das_datum_toStr, but never print the units. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__values.html#ga33090eb744b272db5bab0c36b451926d" title="Write a UTF-8 string representation of a datum to a buffer. ">das_datum_toStr</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga37954af0d57f1908d1a2e8d1024461d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double das_datum_toDbl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdas__datum.html">das_datum</a> *&#160;</td>
          <td class="paramname"><em>pThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a datum value as a double. </p>
<p>This function throws an error if the given datum is not convertable as a double value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pThis</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The double value </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0bc2288f2c65def16a0c30523e29fd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* das_vt_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a>&#160;</td>
          <td class="paramname"><em>vt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default fill value for a given element type. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the default fill value, will have to cast to the appropriate type. </dd></dl>

</div>
</div>
<a class="anchor" id="gad57fd6192612b988a462047161ff35d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a> das_vt_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a>&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__values.html#gae1a009ee25910c8514f20225eb13f530">das_val_type</a>&#160;</td>
          <td class="paramname"><em>left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>What would be the resulting type given an operation on the given value type. </p>
<p>Currently the binary type combining rules are:</p>
<ol type="1">
<li>Unknown combined with anything is unknown.</li>
<li>Index combined with anything is unknown.</li>
<li>ByteSeq combined with anything is unknown.</li>
<li>Text combined with anything is unknown.</li>
<li>Byte, UShort and Short math results in floats.</li>
<li>Int, Long, Float and Double math results in doubles.</li>
<li><p class="startli">If time in involved the following rules apply:</p>
<p class="startli">Time - Time = Double Time +/- (Byte, UShort, Short, Int, Float Double) =&gt; Time</p>
<p class="startli">All other operations invalving times are unknown</p>
</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td></td></tr>
    <tr><td class="paramname">op</td><td>An operation ID. </td></tr>
    <tr><td class="paramname">left</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting type or vtUnknown if the types cannot be combinded via any known operations </dd></dl>

</div>
</div>
<a class="anchor" id="gaa05c3654d91cd080a9e38f6ba4bcbcc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_str2double </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string value to a 8-byte float, similar to strtod(3). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. Conversion stops at the first improper character. Whitespace and leading 0's are ignored in the input.</td></tr>
    <tr><td class="paramname">pRes</td><td>The location to store the resulting 8-byte float.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion succeeded, <code>false</code> otherwise. Among other reason, conversion will fail if the resulting value won't fit in a 8 byte float. </dd></dl>

</div>
</div>
<a class="anchor" id="ga03f95628539dcb28890229288649ccef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_str2int </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the initial portion of a string to an integer with explicit over/underflow checks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. Conversion stops at the first improper character. Whitespace and leading 0's are ignored in the input. The number is assumed to be in base 10, unless the first non-whitespace characters after the optional '+' or '-' sign are '0x'.</td></tr>
    <tr><td class="paramname">pRes</td><td>The location to store the resulting integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion succeeded, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga612a226dc8f4f78200187d9713ab7f71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_str2bool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string value to a boolean value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. The following values are accepted as representing true: 'true' (any case), 'yes' (any case), 'T', 'Y', '1'. The following values are accepted as representing false: 'false' (any case), 'no', (any case), 'F', 'N', '0'. Anything else results in no conversion. </td></tr>
    <tr><td class="paramname">pRes</td><td>the location to store the resulting boolean value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the string could be converted to a boolean, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb20d9148ec64c45c5b4f430ba95c58a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_str2baseint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to an integer with explicit base and overflow checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. Conversion stops at the first improper character. Whitespace and leading 0's are ignored in the input. No assumptions are made about the base of the string. So anything that is not a proper character is the given base is causes an error return.</td></tr>
    <tr><td class="paramname">base</td><td>an integer from 1 to 60 inclusive.</td></tr>
    <tr><td class="paramname">pRes</td><td>The location to store the resulting integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion succeeded, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c94ef724db4e6893617c6061208e2a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool das_strn2baseint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an explicit length string to an integer with explicit base with over/underflow checks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. Conversion stops at the first improper character. Whitespace and leading 0's are ignored in the input. No assumptions are made about the base of the string. So anything that is not a proper character is the given base is causes an error return.</td></tr>
    <tr><td class="paramname">base</td><td>an integer from 1 to 60 inclusive.</td></tr>
    <tr><td class="paramname">nLen</td><td>only look at up to this many characters of input. Encountering whitespace or a '\0' characater will still halt character accumlation.</td></tr>
    <tr><td class="paramname">pRes</td><td>The location to store the resulting integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion succeeded, <code>false</code> otherwise.</dd></dl>
<p>Will only inspect up to 64 non-whitespace characters when converting a value. </p>

</div>
</div>
<a class="anchor" id="gadb99fd0d12418a0b8f086123be132c9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* das_csv2doubles </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nitems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a comma separated list of ASCII values into a double array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The string of comma separated values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nitems</td><td>a pointer to an integer which will be set to the length of the newly allocated array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new double array allocated on the heap. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1f3b3b3dfb9cd9413c1de768cf2bd18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* das_doubles2csv </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nitems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an array of doubles into a string buffer. </p>
<p>Prints an array of doubles into a string buffer with commas and spaces between each entry. Note there is no precision limit for the printing so the space needed to hold the array may 24 bytes times the number number of values, or more.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>this function is a potential source of buffer overruns, fix it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>a pointer to the buffer to receive the printed values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>an array of doubles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nitems</td><td>the number of items to print to the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the supplied buffer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
